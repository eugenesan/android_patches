From 5afb7e8851583d80c592a33f823003d272ae38c8 Mon Sep 17 00:00:00 2001
From: "Eugene San (eugenesan)" <eugenesan@gmail.com>
Date: Mon, 15 Oct 2012 17:49:27 +0200
Subject: [PATCH] PDroid 1.32 - The Better Privacy Protection

PDroid allows blocking access for any installed application to the following data separately:
    Device ID (IMEI/MEID/ESN)
    Subscriber ID (IMSI)
    SIM serial (ICCID)
    Phone and mailbox number
    Incoming call number
    Outgoing call number
    GPS location
    Network location
    List of accounts (including your google e-mail address)
    Account auth tokens
    Contacts
    Call logs
    Calendar
    SMS
    MMS
    Browser bookmarks and history
    System logs
    SIM info (operator, country)
    Network info (operator, country)

For device ID, phone and mailbox number, SIM serial, subscriber ID and device location it also allows supplying custom or random values.

Why you would want to use it:
    Applicaitons do NOT crash when access to private data is blocked (unlike with Permissions Denied or CM)
    Fine-grained tuning of access to private data
    No background service needed
    Very small memory footprint (~700KB)
    No impact on battery life
    No impact on performance (5ms overhead on access to private data; yes, that's 0.005s)
    100% reliable unlike ROOT applications (LBE), which need to start their background service on boot (see android underground to learn why this is an issue)
    No ROOT required for the app to run
    No Android permissions required for the app to run
    Open-source

Requires configuration application from here: http://goo.gl/DTg31

Credits goes to:
svyat at http://forum.xda-developers.com/showthread.php?t=1357056
pastime1971 at http://forum.xda-developers.com/showthread.php?t=1554960

Change-Id: Ie51e5d370318ab01716e15af75ec168ce1aac1bc
---
 Android.mk                                         |   2 +
 core/java/android/app/ContextImpl.java             |  30 +-
 core/java/android/content/ContentResolver.java     |   2 +
 preloaded-classes                                  |   2 +
 .../android/privacy/IPrivacySettingsManager.aidl   |  18 +
 .../java/android/privacy/PrivacyFileObserver.java  |  69 ++
 .../android/privacy/PrivacyPersistenceAdapter.java | 726 +++++++++++++++++++++
 privacy/java/android/privacy/PrivacySettings.aidl  |   4 +
 privacy/java/android/privacy/PrivacySettings.java  | 624 ++++++++++++++++++
 .../android/privacy/PrivacySettingsManager.java    | 188 ++++++
 .../privacy/PrivacySettingsManagerService.java     | 132 ++++
 .../privacy/surrogate/PrivacyAccountManager.java   | 269 ++++++++
 .../surrogate/PrivacyActivityManagerService.java   | 237 +++++++
 .../privacy/surrogate/PrivacyContentResolver.java  | 140 ++++
 .../android/privacy/surrogate/PrivacyCursor.java   | 358 ++++++++++
 .../privacy/surrogate/PrivacyLocationManager.java  | 490 ++++++++++++++
 .../privacy/surrogate/PrivacyTelephonyManager.java | 262 ++++++++
 services/java/com/android/server/SystemServer.java |  12 +
 .../android/server/am/ActivityManagerService.java  |   2 +
 .../java/com/android/server/am/BroadcastQueue.java |  42 ++
 .../java/android/telephony/PhoneStateListener.java |  55 +-
 21 files changed, 3656 insertions(+), 8 deletions(-)
 create mode 100644 privacy/java/android/privacy/IPrivacySettingsManager.aidl
 create mode 100644 privacy/java/android/privacy/PrivacyFileObserver.java
 create mode 100644 privacy/java/android/privacy/PrivacyPersistenceAdapter.java
 create mode 100644 privacy/java/android/privacy/PrivacySettings.aidl
 create mode 100644 privacy/java/android/privacy/PrivacySettings.java
 create mode 100644 privacy/java/android/privacy/PrivacySettingsManager.java
 create mode 100644 privacy/java/android/privacy/PrivacySettingsManagerService.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyCursor.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java

diff --git a/Android.mk b/Android.mk
index aca64fa..6970c77 100644
--- a/Android.mk
+++ b/Android.mk
@@ -218,6 +218,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRemoteControlDisplay.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -322,6 +323,7 @@ aidl_files := \
 	frameworks/base/graphics/java/android/graphics/Region.aidl \
 	frameworks/base/location/java/android/location/Criteria.aidl \
 	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 6d221f2..3c7abe4 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -95,6 +95,11 @@ import android.os.UserId;
 import android.os.SystemVibrator;
 import android.os.SystemProperties;
 import android.os.storage.StorageManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.content.ClipboardManager;
 import android.util.*;
@@ -165,6 +170,7 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    private static Context sOuterContext;
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -278,7 +284,7 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    return new PrivacyAccountManager(ctx, service);
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -373,7 +379,8 @@ class ContextImpl extends Context {
         registerService(LOCATION_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+                    ILocationManager service = ILocationManager.Stub.asInterface(b);
+                    return new PrivacyLocationManager(service,ctx);
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -443,7 +450,7 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -505,6 +512,13 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     return WimaxHelper.createWimaxService(ctx, ctx.mMainThread.getHandler());
                 }});
+
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(),service);
+                }});
     }
 
     static ContextImpl getImpl(Context context) {
@@ -1572,7 +1586,7 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1587,7 +1601,7 @@ class ContextImpl extends Context {
         mResources = context.mResources;
         mMainThread = context.mMainThread;
         mContentResolver = context.mContentResolver;
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     static void init(ActivityThread thread) {
@@ -1737,13 +1751,17 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 0a5a26a..5a84b94 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -39,6 +39,7 @@ import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
+import android.privacy.surrogate.PrivacyContentResolver;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -381,6 +382,7 @@ public abstract class ContentResolver {
                 qCursor = stableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
             }
+            qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
             if (qCursor == null) {
                 return null;
             }
diff --git a/preloaded-classes b/preloaded-classes
index 30703db..2d28912 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -647,6 +647,8 @@ android.os.storage.IMountService$Stub
 android.os.storage.IMountService$Stub$Proxy
 android.preference.PreferenceActivity
 android.preference.PreferenceManager
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
 android.provider.BaseColumns
 android.provider.Settings$NameValueCache
 android.provider.Settings$NameValueTable
diff --git a/privacy/java/android/privacy/IPrivacySettingsManager.aidl b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
new file mode 100644
index 0000000..97f4837
--- /dev/null
+++ b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
@@ -0,0 +1,18 @@
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    double getVersion();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+}
diff --git a/privacy/java/android/privacy/PrivacyFileObserver.java b/privacy/java/android/privacy/PrivacyFileObserver.java
new file mode 100644
index 0000000..21742d2
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyFileObserver.java
@@ -0,0 +1,69 @@
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/** {@hide} */
+public class PrivacyFileObserver extends FileObserver {
+    public static final String TAG = "PrivacyFileObserver";
+    public static final int PACKAGE_PATH_INDEX = 3;
+    public String absolutePath;
+    private PrivacySettingsManagerService pSetManServ;
+    public HashMap<String, PrivacyFileObserver> children;
+
+    public PrivacyFileObserver(String path, PrivacySettingsManagerService pSetManServ) {
+        super(path, FileObserver.ALL_EVENTS);
+        this.absolutePath = path;
+        this.pSetManServ = pSetManServ;
+        this.children = new HashMap<String, PrivacyFileObserver>();
+        File thisFile = new File(absolutePath);
+
+        if (thisFile.isDirectory()) {
+            File[] subfiles = thisFile.listFiles();
+            for (File file : subfiles) {
+                String observePath = file.getAbsolutePath();
+                PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+                children.put(observePath, child);
+                // don't watch directories, only the settings files
+                if (file.isFile()) child.startWatching();
+            }
+        }
+    }
+
+    @Override
+    public void onEvent(int event, String path) {
+        if ((FileObserver.ACCESS & event) != 0) {
+            // data was read from a file
+            StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+            for (int i = 0; i < PACKAGE_PATH_INDEX && tokenizer.hasMoreElements(); i++) {
+                tokenizer.nextToken();
+            }
+
+            // get the package and UID of accessing application
+            String packageName = tokenizer.nextToken();
+
+            // read the setting
+            PrivacySettings pSet = pSetManServ.getSettings(packageName);
+            pSetManServ.notification(packageName, pSet.getSystemLogsSetting(), PrivacySettings.DATA_SYSTEM_LOGS, null);
+        }
+    }
+
+    public void addObserver(String relativePath) {
+        String observePath = absolutePath + "/" + relativePath;
+        // remove existing observer(s) if any
+        // child observers should be destroyed at next GC
+        children.remove(observePath);
+        // create new observer(s)
+        PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+        children.put(observePath, child);
+    }
+
+    @Override
+    public void startWatching() {
+        super.startWatching();
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacyPersistenceAdapter.java b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
new file mode 100644
index 0000000..8e163f9
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
@@ -0,0 +1,726 @@
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public class PrivacyPersistenceAdapter {
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    private static final int RETRY_QUERY_COUNT = 5;
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    private static final int DATABASE_VERSION = 3;
+    public static final int DUMMY_UID = -1;
+
+    /**
+     * Number of threads currently reading the database
+     */
+    public static Integer readingThreads = 0;
+
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+    private static final String TABLE_SETTINGS = "settings";
+    private static final String TABLE_MAP = "map";
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    private static final String TABLE_VERSION = "version";
+    private static final String CREATE_TABLE_SETTINGS =
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " +
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " +
+        " packageName TEXT, " +
+        " uid INTEGER, " +
+        " deviceIdSetting INTEGER, " +
+        " deviceId TEXT, " +
+        " line1NumberSetting INTEGER, " +
+        " line1Number TEXT, " +
+        " locationGpsSetting INTEGER, " +
+        " locationGpsLat TEXT, " +
+        " locationGpsLon TEXT, " +
+        " locationNetworkSetting INTEGER, " +
+        " locationNetworkLat TEXT, " +
+        " locationNetworkLon TEXT, " +
+        " networkInfoSetting INTEGER, " +
+        " simInfoSetting INTEGER, " +
+        " simSerialNumberSetting INTEGER, " +
+        " simSerialNumber TEXT, " +
+        " subscriberIdSetting INTEGER, " +
+        " subscriberId TEXT, " +
+        " accountsSetting INTEGER, " +
+        " accountsAuthTokensSetting INTEGER, " +
+        " outgoingCallsSetting INTEGER, " +
+        " incomingCallsSetting INTEGER, " +
+        " contactsSetting INTEGER, " +
+        " calendarSetting INTEGER, " +
+        " mmsSetting INTEGER, " +
+        " smsSetting INTEGER, " +
+        " callLogSetting INTEGER, " +
+        " bookmarksSetting INTEGER, " +
+        " systemLogsSetting INTEGER, " +
+        " externalStorageSetting INTEGER, " +
+        " cameraSetting INTEGER, " +
+        " recordAudioSetting INTEGER, " +
+        " notificationSetting INTEGER, " +
+        " intentBootCompletedSetting INTEGER" +
+        ");";
+
+    private static final String CREATE_TABLE_MAP =
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS =
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+    private static final String INSERT_VERSION =
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+    private static final String INSERT_ENABLED =
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+    private static final String INSERT_NOTIFICATIONS_ENABLED =
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid",
+        "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number", "locationGpsSetting",
+        "locationGpsLat", "locationGpsLon", "locationNetworkSetting", "locationNetworkLat",
+        "locationNetworkLon", "networkInfoSetting", "simInfoSetting", "simSerialNumberSetting",
+        "simSerialNumber", "subscriberIdSetting", "subscriberId", "accountsSetting", "accountsAuthTokensSetting",
+        "outgoingCallsSetting", "incomingCallsSetting", "contactsSetting", "calendarSetting",
+        "mmsSetting", "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting",
+        "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting",
+        "intentBootCompletedSetting" };
+
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase db;
+    private Context context;
+
+    public PrivacyPersistenceAdapter(Context context) {
+        this.context = context;
+        // check write permission for /data/system/
+        boolean canWrite = new File("/data/system/").canWrite();
+        // create the database and settings directory if we have write permission and they do not exist
+        if (canWrite) {
+            if (!new File(DATABASE_FILE).exists()) createDatabase();
+            if (!new File(SETTINGS_DIRECTORY).exists()) createSettingsDir();
+            // upgrade if needed
+            int currentVersion = getDbVersion();
+            if (currentVersion < DATABASE_VERSION) upgradeDatabase(currentVersion);
+        }
+    }
+
+    private synchronized void upgradeDatabase(int currentVersion) {
+        Log.i(TAG, "upgradeDatabase - upgrading DB from version " + currentVersion + " to " + DATABASE_VERSION);
+        // backup current database file
+        File dbFile = new File(DATABASE_FILE);
+        File dbBackupFile = new File(DATABASE_FILE + ".bak");
+        // remove old backup
+        try {
+            dbBackupFile.delete();
+        } catch (SecurityException e) {
+            Log.w(TAG, "upgradeDatabase - could not remove old backup");
+        }
+        // backup current DB file
+        FileUtils.copyFile(dbFile, dbBackupFile);
+        // make sure a backup was created
+        if (System.currentTimeMillis() - dbBackupFile.lastModified() > 2000) {
+            Log.e(TAG, "upgradeDatabase - could not create a database backup, aborting...");
+            return;
+        }
+
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction();
+
+        switch (currentVersion) {
+            case 1:
+            case 2:
+                try {
+                    if (db != null && db.isOpen()) {
+                        db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                        db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+                        db.execSQL(CREATE_TABLE_MAP);
+                        db.execSQL(INSERT_VERSION);
+                        db.execSQL(INSERT_ENABLED);
+                        db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+
+                        // remove uid dirs from the settings directory
+                        File settingsDir = new File(SETTINGS_DIRECTORY);
+                        for (File packageDir : settingsDir.listFiles()) {
+                            for (File uidDir : packageDir.listFiles()) {
+                                if (uidDir.isDirectory()) {
+                                    File[] settingsFiles = uidDir.listFiles();
+                                    // copy the first found (most likely the only one) one level up
+                                    if (settingsFiles[0] != null) {
+                                        File newPath = new File(packageDir + "/" + settingsFiles[0].getName());
+                                        newPath.delete();
+                                        settingsFiles[0].renameTo(newPath);
+                                        deleteRecursive(uidDir);
+                                    }
+                                }
+                            }
+                        }
+                        db.setTransactionSuccessful();
+                    }
+                } catch (Exception e) {
+                    if (db != null && db.isOpen()) {
+                        db.endTransaction();
+                        db.close();
+                    }
+                    Log.w(TAG, "upgradeDatabase - could not upgrade DB; will restore backup", e);
+                    FileUtils.copyFile(dbBackupFile, dbFile);
+                    dbBackupFile.delete();
+                }
+                break;
+            case 3:
+                // most current version, do nothing
+                Log.w(TAG, "upgradeDatabase - trying to upgrade most current DB version");
+                break;
+        }
+
+        if (db != null && db.isOpen()) {
+            db.endTransaction();
+            db.close();
+        } else {
+            Log.e(TAG, "upgradeDatabase - database is null or closed; cant call endTransaction()");
+        }
+        purgeSettings();
+    }
+
+    private int getDbVersion() {
+        int version = -1;
+        // check if the table "map" exists; if it doesn't -> return version 1
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        try {
+            Cursor c = rawQuery(db, "SELECT name FROM sqlite_master WHERE type='table' AND name='" + TABLE_MAP + "';");
+            if (c != null) {
+                if (c.getCount() == 0) {
+                    // table map does not exist
+                    version = 1;
+                }
+                c.close();
+                synchronized (readingThreads) {
+                    readingThreads--;
+                    // only close DB if no other threads are reading
+                    if (readingThreads == 0 && db != null && db.isOpen()) {
+                        db.close();
+                    }
+                }
+            } else {
+                Log.e(TAG, "getDbVersion - failed to check if table map exists (cursor is null)");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to check if table map exists (exception)");
+        }
+        if (version == 1) return version;
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) return 1;
+
+        int versionNum;
+        try {
+            versionNum = Integer.parseInt(versionString);
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to parse database version; returning 1");
+            return 1;
+        }
+        return versionNum;
+    }
+
+    public String getValue(String name) {
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c;
+        String output = null;
+
+        try {
+            c = query(db, TABLE_MAP, new String[] { "value" }, "name=?",
+                    new String[] { name }, null, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                output = c.getString(c.getColumnIndex("value"));
+                c.close();
+            } else {
+                Log.w(TAG, "getValue - could not get value for name: " + name);
+            }
+        } catch (Exception e) {
+            Log.w(TAG, "getValue - could not get value for name: " + name, e);
+        }
+
+        synchronized (readingThreads) {
+            readingThreads--;
+            // only close DB if no other threads are reading
+            if (readingThreads == 0 && db != null && db.isOpen()) {
+                db.close();
+            }
+        }
+        return output;
+    }
+
+    public synchronized boolean setValue(String name, String value) {
+        Log.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+        SQLiteDatabase db = getWritableDatabase();
+        boolean success = db.replace(TABLE_MAP, null, values) != -1;
+        if (readingThreads == 0 && db != null && db.isOpen()) db.close();
+        return success;
+    }
+
+    public synchronized PrivacySettings getSettings(String packageName, boolean forceCloseDB) {
+        PrivacySettings s = null;
+
+        if (packageName == null) {
+            Log.e(TAG, "getSettings - insufficient application identifier - package name is required");
+            return s;
+        }
+
+        // indicate that the DB is being read to prevent closing by other threads
+        readingThreads++;
+
+        SQLiteDatabase db;
+        try {
+            db = getReadableDatabase();
+        } catch (SQLiteException e) {
+            Log.e(TAG, "getSettings - database could not be opened", e);
+            readingThreads--;
+            return s;
+        }
+
+        Cursor c = null;
+
+        try {
+            c = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?", new String[] { packageName }, null, null, null, null);
+
+            if (c != null && c.moveToFirst()) {
+                s = new PrivacySettings(c.getInt(0), c.getString(1), c.getInt(2), (byte)c.getShort(3), c.getString(4),
+                        (byte)c.getShort(5), c.getString(6), (byte)c.getShort(7), c.getString(8), c.getString(9), (byte)c.getShort(10),
+                        c.getString(11), c.getString(12), (byte)c.getShort(13), (byte)c.getShort(14), (byte)c.getShort(15),
+                        c.getString(16), (byte)c.getShort(17), c.getString(18), (byte)c.getShort(19), (byte)c.getShort(20),
+                        (byte)c.getShort(21), (byte)c.getShort(22), (byte)c.getShort(23), (byte)c.getShort(24), (byte)c.getShort(25),
+                        (byte)c.getShort(26), (byte)c.getShort(27), (byte)c.getShort(28), (byte)c.getShort(29), (byte)c.getShort(30),
+                        (byte)c.getShort(31), (byte)c.getShort(32), (byte)c.getShort(33), (byte)c.getShort(34), null);
+
+                // get allowed contacts IDs if necessary
+                c = rawQuery(db, "SELECT * FROM allowed_contacts WHERE settings_id=" + Integer.toString(s.get_id()) + ";");
+
+                if (c != null && c.getCount() > 0) {
+                    int[] allowedContacts = new int[c.getCount()];
+                    while (c.moveToNext()) allowedContacts[c.getPosition()] = c.getInt(1);
+                    s.setAllowedContacts(allowedContacts);
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+            e.printStackTrace();
+            if (c != null) c.close();
+        } finally {
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+        return s;
+    }
+
+    /**
+     * Saves the settings object fields into DB and into plain text files where applicable.
+     * The DB changes will not be made persistent if saving settings to plain text files
+     * fails.
+     * @param s settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public synchronized boolean saveSettings(PrivacySettings s) {
+        boolean result = true;
+        String packageName = s.getPackageName();
+
+        if (packageName == null || packageName.isEmpty()/* || uid == null*/) {
+            Log.e(TAG, "saveSettings - either package name, UID or both is missing");
+            return false;
+        }
+
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+        values.put("uid", DUMMY_UID);
+
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());
+        values.put("simInfoSetting", s.getSimInfoSetting());
+
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());
+        values.put("subscriberId", s.getSubscriberId());
+
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+
+        readingThreads++;
+        SQLiteDatabase db = getWritableDatabase();
+        // make sure this ends up in a consistent state (DB and plain text files)
+        db.beginTransaction();
+
+        Cursor c = null;
+        try {
+            // save settings to the DB
+            Integer id = s.get_id();
+            if (id != null) {
+                // existing entry -> update
+                if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                    throw new Exception("saveSettings - failed to update database entry");
+                }
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                int[] allowedContacts = s.getAllowedContacts();
+                if (allowedContacts != null) {
+                    ContentValues contactsValues = new ContentValues();
+                    for (int i = 0; i < allowedContacts.length; i++) {
+                        contactsValues.put("settings_id", id);
+                        contactsValues.put("contact_id", allowedContacts[i]);
+                        if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                            throw new Exception("saveSettings - failed to update database entry (contacts)");
+                    }
+                }
+            } else {
+                // new entry -> insert if no duplicates exist
+                c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                        new String[] { s.getPackageName() }, null, null, null);
+
+                if (c != null) {
+                    // exactly one entry
+                    if (c.getCount() == 1) {
+                        // exists -> update
+                        if (db.update(TABLE_SETTINGS, values, "packageName=?",
+                                new String[] { s.getPackageName() }) < 1) {
+                            throw new Exception("saveSettings - failed to update database entry");
+                        }
+
+                        if (c.moveToFirst()) {
+                            // id of the found duplicate entry
+                            Integer idAlt = c.getInt(0);
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { idAlt.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", idAlt);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                        throw new Exception("saveSettings - failed to update database entry (contacts)");
+                                }
+                            }
+                        }
+                    // no entries -> insert
+                    } else if (c.getCount() == 0) {
+                        long rowId = db.insert(TABLE_SETTINGS, null, values);
+                        if (rowId == -1) {
+                            throw new Exception("saveSettings - failed to insert new record into DB");
+                        }
+
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Long.toString(rowId) });
+                        int[] allowedContacts = s.getAllowedContacts();
+                        if (allowedContacts != null) {
+                            ContentValues contactsValues = new ContentValues();
+                            for (int i = 0; i < allowedContacts.length; i++) {
+                                contactsValues.put("settings_id", rowId);
+                                contactsValues.put("contact_id", allowedContacts[i]);
+                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                    throw new Exception("saveSettings - failed to update database entry (contacts)");
+                            }
+                        }
+                    } else {
+                        // something went totally wrong and there are multiple entries for same identifier
+                        result = false;
+                        throw new Exception("saveSettings - duplicate entries in the privacy.db");
+                    }
+                } else {
+                    result = false;
+                    // jump to catch block to avoid marking transaction as successful
+                    throw new Exception("saveSettings - cursor is null, database access failed");
+                }
+            }
+
+            // save settings to plain text file (for access from core libraries)
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/systemLogsSetting");
+            try {
+                // make the parent directory readable (requires it to be executable as well)
+                settingsPackageDir.mkdirs();
+                settingsPackageDir.setReadable(true, false);
+                settingsPackageDir.setExecutable(true, false);
+                // create the setting files and make them readable
+                systemLogsSettingFile.createNewFile();
+                systemLogsSettingFile.setReadable(true, false);
+                // write settings to files
+                OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(systemLogsSettingFile));
+                writer.append(s.getSystemLogsSetting() + "");
+                writer.flush();
+                writer.close();
+            } catch (IOException e) {
+                result = false;
+                // jump to catch block to avoid marking transaction as successful
+                throw new Exception("saveSettings - could not write settings to file", e);
+            }
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+        } catch (Exception e) {
+            result = false;
+        } finally {
+            db.endTransaction();
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Deletes a settings entry from the DB
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public synchronized boolean deleteSettings(String packageName) {
+        boolean result = true;
+
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+        try {
+            // try deleting contacts allowed entries; do not fail if deletion not possible
+            Cursor c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                    new String[] { packageName }, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                int id = c.getInt(0);
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Integer.toString(id) });
+                c.close();
+            }
+
+            if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                return false;
+            }
+
+            // delete settings from plain text file (for access from core libraries)
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/systemLogsSetting");
+            // delete the setting files
+            systemLogsSettingFile.delete();
+            if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0) settingsPackageDir.delete();
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+        } catch (Exception e) {
+            result = false;
+            Log.e(TAG, "deleteSettings - could not delete settings", e);
+        } finally {
+            db.endTransaction();
+            if (db != null && db.isOpen()) db.close();
+        }
+        return result;
+    }
+
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection,
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used in methods, which rely on the DB
+     * being open after this method has finished. It will close the DB if no other threads has increased
+     * the readingThread count.
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+
+        // get installed apps
+        List<String> apps = new ArrayList<String>();
+        PackageManager pMan = context.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(PackageManager.GET_META_DATA);
+        for (ApplicationInfo appInfo : installedApps) {
+            apps.add(appInfo.packageName);
+        }
+
+        // delete obsolete settings directories
+        File settingsDir = new File(SETTINGS_DIRECTORY);
+        for (File packageDir : settingsDir.listFiles()) {
+            String packageName = packageDir.getName();
+
+            // remove package dir if no such app installed
+            if (!apps.contains(packageName)) {
+                deleteRecursive(packageDir);
+            }
+        }
+
+        // delete obsolete entries from DB and update outdated entries
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c = null;
+        try {
+            c = query(db, TABLE_SETTINGS, new String[] {"packageName"}, null, null, null, null, null, null);
+            List<String> appsInDb = new ArrayList<String>();
+            while (c.moveToNext()) {
+                String packageName = c.getString(0);
+                if (!apps.contains(packageName)) {
+                    deleteSettings(packageName);
+                } else {
+                    // if duplicate entry, remove all duplicates and keep only one
+                    if (appsInDb.contains(packageName)) {
+                        PrivacySettings pSetTmp = getSettings(packageName, false);
+                        deleteSettings(packageName);
+                        saveSettings(pSetTmp);
+                    } else {
+                        appsInDb.add(packageName);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "purgeSettings - purging DB failed", e);
+            result = false;
+        } finally {
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+        return result;
+    }
+
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles()) deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+
+    private synchronized void createDatabase() {
+        Log.i(TAG, "createDatabase - creating privacy database file");
+        try {
+            SQLiteDatabase db =
+                SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE |
+                        SQLiteDatabase.CREATE_IF_NECESSARY);
+            Log.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+            if (db != null && db.isOpen()) db.close();
+        } catch (SQLException e) {
+            Log.e(TAG, "createDatabase - failed to create privacy database", e);
+        }
+    }
+
+    private synchronized void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+
+    private synchronized SQLiteDatabase getReadableDatabase() {
+        if (db != null && db.isOpen()) return db;
+
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READONLY);
+
+        return db;
+    }
+
+    private synchronized SQLiteDatabase getWritableDatabase() {
+        // create the database if it does not exist
+        if (!new File(DATABASE_FILE).exists()) createDatabase();
+
+        if (db != null && db.isOpen() && !db.isReadOnly()) return db;
+
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+
+        return db;
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettings.aidl b/privacy/java/android/privacy/PrivacySettings.aidl
new file mode 100644
index 0000000..59d1899
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.aidl
@@ -0,0 +1,4 @@
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff --git a/privacy/java/android/privacy/PrivacySettings.java b/privacy/java/android/privacy/PrivacySettings.java
new file mode 100644
index 0000000..0887594
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.java
@@ -0,0 +1,624 @@
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacySettings implements Parcelable {
+    /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings,
+     * it is setter method caller's responsibility to make sure that the corresponding
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     *
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+
+    // Database entry ID
+    private final Integer _id;
+
+    // Application identifiers
+    private String packageName;
+    private int uid;
+
+    //
+    // Privacy settings
+    //
+
+    private byte deviceIdSetting;
+    private String deviceId;
+
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting;
+    private String line1Number;
+
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    // browser bookmarks and history
+    private byte bookmarksSetting;
+    private byte systemLogsSetting;
+    private byte notificationSetting;
+    private byte intentBootCompletedSetting;
+
+    private int[] allowedContacts;
+
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        this.packageName = packageName;
+        this.uid = uid;
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+        this.allowedContacts = null;
+    }
+
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat,
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting,
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting,
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting,
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts) {
+        this._id = id;
+        this.packageName = packageName;
+        this.uid = uid;
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+        this.allowedContacts = allowedContacts;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+        this.allowedContacts = in.createIntArray();
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+        dest.writeIntArray(allowedContacts);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManager.java b/privacy/java/android/privacy/PrivacySettingsManager.java
new file mode 100644
index 0000000..0f153b9
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManager.java
@@ -0,0 +1,188 @@
+package android.privacy;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public class PrivacySettingsManager {
+    private static final String TAG = "PrivacySettingsManager";
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    private IPrivacySettingsManager service;
+
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+        this.service = service;
+    }
+
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+
+    public PrivacySettings getSettings(String packageName) {
+        try {
+            if (service != null) {
+                return service.getSettings(packageName);
+            } else {
+                Log.e(TAG, "getSettings - PrivacySettingsManagerService is null");
+                return null;
+            }
+        } catch (RemoteException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        try {
+            if (service != null) {
+                return service.saveSettings(settings);
+            } else {
+                Log.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in saveSettings: ", e);
+            return false;
+        }
+    }
+
+    public boolean deleteSettings(String packageName) {
+        return deleteSettings(packageName);
+    }
+
+    public boolean deleteSettings(String packageName, int uid) {
+        try {
+            if (service != null) {
+                return service.deleteSettings(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in deleteSettings: ", e);
+            return false;
+        }
+    }
+
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    public boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output, pSet);
+    }
+
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        try {
+            if (service != null) {
+                service.notification(packageName, accessMode, dataType, output);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in notification: ", e);
+        }
+    }
+
+    public void registerObservers() {
+        try {
+            if (service != null) {
+                service.registerObservers();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in registerObservers: ", e);
+        }
+    }
+
+    public void addObserver(String packageName) {
+        try {
+            if (service != null) {
+                service.addObserver(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in addObserver: ", e);
+        }
+    }
+
+    public boolean purgeSettings() {
+        try {
+            if (service != null) {
+                return service.purgeSettings();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in purgeSettings: ", e);
+        }
+        return false;
+    }
+
+    public double getVersion() {
+        try {
+            if (service != null) {
+                return service.getVersion();
+            } else {
+                Log.e(TAG, "getVersion - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in getVersion: ", e);
+        }
+        return 0;
+    }
+
+    public boolean setEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setEnabled(enable);
+            } else {
+                Log.e(TAG, "setEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setEnabled: ", e);
+        }
+        return false;
+    }
+
+    public boolean setNotificationsEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+                Log.e(TAG, "setNotificationsEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setNotificationsEnabled: ", e);
+        }
+        return false;
+    }
+
+    public void setBootCompleted() {
+        try {
+            if (service != null) {
+                service.setBootCompleted();
+            } else {
+                Log.e(TAG, "setBootCompleted - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setBootCompleted: ", e);
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManagerService.java b/privacy/java/android/privacy/PrivacySettingsManagerService.java
new file mode 100644
index 0000000..8da8fef
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManagerService.java
@@ -0,0 +1,132 @@
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * @author Svyatoslav Hresyk
+ * TODO: add selective contact access management API
+ * {@hide}
+ */
+public class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+    private static final String TAG = "PrivacySettingsManagerService";
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+    private PrivacyPersistenceAdapter persistenceAdapter;
+    private Context context;
+    public static PrivacyFileObserver obs;
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+    private static final double VERSION = 1.32;
+
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        Log.i(TAG, "PrivacySettingsManagerService - initializing for package: " + context.getPackageName() +
+                " UID: " + Binder.getCallingUid());
+        this.context = context;
+
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+
+    public PrivacySettings getSettings(String packageName) {
+        if (enabled || context.getPackageName().equals("com.privacy.pdroid"))
+            return persistenceAdapter.getSettings(packageName, false);
+        else return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        Log.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        Log.d(TAG, "saveSettings - " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true) obs.addObserver(settings.getPackageName());
+        return result;
+    }
+
+    public boolean deleteSettings(String packageName) {
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+
+    public double getVersion() {
+        return VERSION;
+    }
+
+    public void notification(final String packageName, final byte accessMode, final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled) {
+            Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent);
+        }
+    }
+
+    public void registerObservers() {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+
+    public void addObserver(String packageName) {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        obs.addObserver(packageName);
+    }
+
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+
+    public boolean setNotificationsEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED, value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public boolean setEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
new file mode 100644
index 0000000..4c4f753
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
@@ -0,0 +1,269 @@
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    private static final String TAG = "PrivacyAccountManager";
+    private Context context;
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+
+        return output;
+    }
+
+    /**
+     * USE_CREDENTIALS
+     */
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        }
+
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        }
+
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        }
+
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);
+        }
+
+        return output;
+    }
+
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        private V result;
+
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
new file mode 100644
index 0000000..eef1131
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
@@ -0,0 +1,237 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.PrivacySettingsManagerService;
+import android.provider.Telephony;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    private static final String TAG = "PrivacyActivityManagerService";
+    private static PrivacySettingsManager pSetMan;
+
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+
+    private static long tmpPackageAddedHash = 0;
+
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to
+     * privacy permissions
+     * @param packageName may not be null
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else {
+                // free memory after all receivers have been served
+                tmpOut = null;
+            }
+
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+
+            pSet = pSetMan.getSettings(packageName, uid);
+
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else {
+                // free memory after all receivers have been served
+                tmpIn = null;
+            }
+
+        // incoming SMS
+        } else if (action.equals(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+            }
+
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else {
+                // free memory after all receivers have been served
+                tmpSms = null;
+            }
+
+        // incoming MMS
+        } else if (action.equals(Telephony.Sms.Intents.WAP_PUSH_RECEIVED_ACTION) ||
+                action.equals(Telephony.Sms.Intents.DATA_SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+            }
+
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else {
+                // free memory after all receivers have been served
+                tmpMms = null;
+            }
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) {
+                    // update the UID
+                    pSet.setUid(addedUid);
+                    pSetMan.saveSettings(pSet);
+                }
+            }
+        }
+    }
+
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
new file mode 100644
index 0000000..ad2a901
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
@@ -0,0 +1,140 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.IContentProvider;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+    private static final String TAG = "PrivacyContentResolver";
+    private static PrivacySettingsManager pSetMan;
+
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM &&
+                                   uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                            }
+
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else {
+                            // real
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    }
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                } else if (auth.equals(Mms.CONTENT_URI.getAuthority())) {
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                } else if (auth.equals(Sms.CONTENT_URI.getAuthority())) {
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MmsSms.CONTENT_URI.getAuthority()) ||
+                           auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) {
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null &&
+                        (pSet.getMmsSetting() == PrivacySettings.EMPTY ||
+                         pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                }
+            }
+            return output;
+        }
+        return realCursor;
+    }
+
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyCursor.java b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
new file mode 100644
index 0000000..da260ea
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
@@ -0,0 +1,358 @@
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Map;
+
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver}
+ * when access should be blocked without crashing the calling application (for this purpose none
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    private Cursor realCursor;
+    private int[] allowedIds;
+    private int[] allowedIdMapping;
+    private final static String TAG = "PrivacyCursor";
+
+    public PrivacyCursor() {
+    }
+
+    /**
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+
+    @Override
+    public void close() {
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+        if (realCursor != null) {
+            Log.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+        if (realCursor != null) {
+            int result = getMappedPos(realCursor.getPosition());
+            Log.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null) {
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null) {
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null) {
+            Log.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+        if (realCursor != null) realCursor.registerContentObserver(observer);
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);
+    }
+
+    @Override
+    public boolean requery() {
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+        if (realCursor != null) return realCursor.respond(extras);
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex);
+        return result;
+    }
+
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+        return result;
+    }
+
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
new file mode 100644
index 0000000..d4e7e84
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
@@ -0,0 +1,490 @@
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+    private static final String TAG = "PrivacyLocationManager";
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    private Context context;
+    private PrivacySettingsManager pSetMan;
+    private Object lock = new Object();
+
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(context, service);
+        this.context = context;
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        Location output = null;
+
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS,
+                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS,
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS,
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK,
+                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK,
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK,
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) &&
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL &&
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS,
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK,
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS,
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        LocationProvider output = null;
+
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL ||
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) {
+                // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL ||
+                    pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else {
+            // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) {
+            // custom listener should only return a value after this method has returned
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent,
+                                        Double.parseDouble(pSet.getLocationGpsLat()),
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS,
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent,
+                                        Double.parseDouble(pSet.getLocationGpsLat()),
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS,
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent,
+                                        Double.parseDouble(pSet.getLocationNetworkLat()),
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK,
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent,
+                                        Double.parseDouble(pSet.getLocationNetworkLat()),
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK,
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) {
+                    // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL &&
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else {
+                    // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            return output;
+        }
+    }
+
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE ||
+                 criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH ||
+                 criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH ||
+                 criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH ||
+                 criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            // treat providers with high accuracy as GPS providers
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else {
+            // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+
+    private class PrivacyLocationUpdater extends Thread {
+        private String provider;
+        private LocationListener listener;
+        private PendingIntent intent;
+        private double latitude;
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                                      double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
new file mode 100644
index 0000000..e257ceb
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
@@ -0,0 +1,262 @@
+package android.privacy.surrogate;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+    private static final String TAG = "PrivacyTelephonyManager";
+    private Context context;
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException:
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+    }
+
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            // can be empty, custom or random
+            output = pSet.getLine1Number();
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+    }
+
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            // can be empty, custom or random
+            output = pSet.getLine1Number();
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+    }
+
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+
+        return output;
+    }
+
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+        return output;
+    }
+
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);
+            // can only be empty
+            return "";
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);
+            return null;
+        }
+    }
+
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+        return output;
+    }
+
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+            // can only be empty
+            return "";
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+            return null;
+        }
+    }
+
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            // can be empty, custom or random
+            output = pSet.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet);
+        } else {
+            output = super.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);
+        }
+        return output;
+    }
+
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            // can be empty, custom or random
+            output = pSet.getSubscriberId();
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        }
+        return output;
+    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) ||
+                ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+            listener.setContext(context);
+            listener.setPackageName(context.getPackageName());
+            listener.setUid(Binder.getCallingUid());
+            super.listen(listener, events);
+        } else {
+            super.listen(listener, events);
+        }
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 79add3a..f11ae63 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -39,6 +39,7 @@ import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
 import android.os.SystemProperties;
+import android.privacy.PrivacySettingsManagerService;
 import android.provider.Settings;
 import android.server.BluetoothA2dpService;
 import android.server.BluetoothService;
@@ -225,6 +226,8 @@ class ServerThread extends Thread {
             contentService = ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
 
+            addPrivacyService(context);
+
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
 
@@ -975,6 +978,15 @@ class ServerThread extends Thread {
         Slog.d(TAG, "Starting service: " + intent);
         context.startService(intent);
     }
+
+    private void addPrivacyService(Context context) {
+        try {
+            Log.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }
+    }
 }
 
 public class SystemServer {
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 14bc978..73f9764 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -12794,6 +12794,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 r.resultExtras, r.resultAbort, true);
                         if (doNext) {
                             doTrim = true;
+                            r.queue.setContext(mContext);
                             r.queue.processNextBroadcast(false);
                         }
                     }
@@ -13301,6 +13302,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
 
             if (doNext) {
+                r.queue.setContext(mContext);
                 r.queue.processNextBroadcast(false);
             }
             trimApplications();
diff --git a/services/java/com/android/server/am/BroadcastQueue.java b/services/java/com/android/server/am/BroadcastQueue.java
index 47b8c0a..a7cc4bd 100644
--- a/services/java/com/android/server/am/BroadcastQueue.java
+++ b/services/java/com/android/server/am/BroadcastQueue.java
@@ -22,6 +22,7 @@ import java.util.ArrayList;
 
 import android.app.AppGlobals;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.IIntentReceiver;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -34,6 +35,7 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserId;
+import android.privacy.surrogate.PrivacyActivityManagerService;
 import android.util.EventLog;
 import android.util.Slog;
 
@@ -444,6 +446,20 @@ public class BroadcastQueue {
         }
     }
 
+    /**
+     * {@hide}
+     * Empty copy of context for privacy protection
+     */
+    Context mContext = null;
+
+    /**
+     * {@hide}
+     * Copy of context for privacy protection
+     */
+    public void setContext(Context context) {
+        mContext = context;
+    }
+
     final void processNextBroadcast(boolean fromMsg) {
         synchronized(mService) {
             BroadcastRecord r;
@@ -623,6 +639,7 @@ public class BroadcastQueue {
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+            enforcePrivacyPermission(nextReceiver, r);
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -787,6 +804,31 @@ public class BroadcastQueue {
         }
     }
 
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (mContext != null && r != null && r.intent != null && r.intent.getAction() != null) {
+
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, mContext, r.receivers.size());
+            }
+        }
+    }
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index 698206c..02c38dd 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -28,6 +28,10 @@ import android.util.Log;
 import com.android.internal.telephony.IPhoneStateListener;
 import com.android.internal.telephony.Phone;
 
+import android.content.Context;
+
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
 /**
  * A listener class for monitoring changes in specific telephony states
  * on the device, including service state, signal strength, message
@@ -165,6 +169,26 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_CELL_INFO = 0x00000400;
 
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener";
+
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
     public PhoneStateListener() {
     }
 
@@ -323,11 +347,38 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                }
+            }
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
-- 
1.8.0

