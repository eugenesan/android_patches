From 4038e85910f0d55954ca0601bb1587009aefebea Mon Sep 17 00:00:00 2001
From: "Eugene San (eugenesan)" <eugenesan@gmail.com>
Date: Tue, 15 Jan 2013 18:25:49 +0200
Subject: [PATCH] openpdroid 1.51 - the better privacy protection

OpenPDroid is a set of modifications to the Android framework and
libraries which allows fine-tuning of the data which applications
are able to retrieve about your device, your account, your messages,
and more. Specifically, it is a Privacy service provider
(using the PDroid 1.51 interface) forked from CollegeDev's PDroid 2.0,
which is itself an extension of Syvat's PDroid.

What (specifically) can I control with OpenPDroid?
Data access:
    Device ID (IMEI/MEID/ESN)
    Phone/voicemail number
    Sim Card Serial (ICCID)
    Subscriber ID (IMSI)
    Source number of incoming calls
    Destination number of outgoing calls
    Network location
    GPS location
    Authentication credentials
    List of accounts, including identifiers (e.g. gmail e-mail address)
    Contact list and details
    Call log
    Calendar
    Read and send SMS
    Read and send MMS
    Record audio (not phone calls)
    Camera
    Browser bookmarks and history
    System logs
    Wifi Info, such as current access point, IP address
    Network information (detailed network information such as
    connection state, IP address, etc)
    Android ID (a unique installation ID for your Android installation)
    SIM information (your phone operator and country)
    Restrict access to iptables command
    ICC Access (reading or writing SMS on the SIM or R-UIM)

Actions:
    Make phone calls
    Start on Boot (or more accurately, get notified when the boot is complete)
    Switch Wifi State (turn wifi on and off, change access points)
    Switch network state (turn off or on mobile data)

Other:
    Force online state (always tell the app that the device is online: only
    needed if denying Wifi info and/or Network info)

Change-Id: Ib7b4872fcb9a883291906775aff7bde20365554e
---
 Android.mk                                         |    2 +
 api/current.txt                                    |    1 +
 core/java/android/app/ContextImpl.java             |   56 +-
 core/java/android/app/Instrumentation.java         |  347 +++++++
 core/java/android/content/ContentResolver.java     |    5 +
 core/java/android/hardware/Camera.java             |  204 +++-
 core/java/android/net/NetworkInfo.java             |    9 +
 core/java/android/os/SystemProperties.java         |  139 +++
 core/java/android/provider/Settings.java           |  101 ++
 .../android/speech/srec/MicrophoneInputStream.java |  137 ++-
 media/java/android/media/AudioRecord.java          |  143 ++-
 media/java/android/media/MediaRecorder.java        |  516 +++++++++-
 preloaded-classes                                  |   13 +
 .../android/privacy/IPrivacySettingsManager.aidl   |   30 +
 .../java/android/privacy/PrivacyFileObserver.java  |  125 +++
 .../android/privacy/PrivacyPersistenceAdapter.java | 1036 ++++++++++++++++++++
 privacy/java/android/privacy/PrivacySettings.aidl  |   16 +
 privacy/java/android/privacy/PrivacySettings.java  | 1027 +++++++++++++++++++
 .../android/privacy/PrivacySettingsManager.java    |  215 ++++
 .../privacy/PrivacySettingsManagerService.java     |  236 +++++
 .../privacy/surrogate/PrivacyAccountManager.java   |  297 ++++++
 .../surrogate/PrivacyActivityManagerService.java   |  296 ++++++
 .../surrogate/PrivacyConnectivityManager.java      |  206 ++++
 .../privacy/surrogate/PrivacyContentResolver.java  |  251 +++++
 .../android/privacy/surrogate/PrivacyCursor.java   |  496 ++++++++++
 .../privacy/surrogate/PrivacyLocationManager.java  |  532 ++++++++++
 .../privacy/surrogate/PrivacyTelephonyManager.java |  520 ++++++++++
 .../privacy/surrogate/PrivacyWifiManager.java      |  207 ++++
 .../android/server/PrivacyTelephonyRegistry.java   |  402 ++++++++
 services/java/com/android/server/SystemServer.java |   15 +-
 .../java/com/android/server/TelephonyRegistry.java |   46 +-
 .../java/com/android/server/am/BroadcastQueue.java |   51 +-
 telephony/java/android/telephony/CellInfoGsm.java  |    2 +-
 .../java/android/telephony/PhoneStateListener.java |   61 +-
 telephony/java/android/telephony/ServiceState.java |    2 +-
 wifi/java/android/net/wifi/WifiInfo.java           |   14 +
 36 files changed, 7709 insertions(+), 47 deletions(-)
 create mode 100644 privacy/java/android/privacy/IPrivacySettingsManager.aidl
 create mode 100644 privacy/java/android/privacy/PrivacyFileObserver.java
 create mode 100644 privacy/java/android/privacy/PrivacyPersistenceAdapter.java
 create mode 100644 privacy/java/android/privacy/PrivacySettings.aidl
 create mode 100644 privacy/java/android/privacy/PrivacySettings.java
 create mode 100644 privacy/java/android/privacy/PrivacySettingsManager.java
 create mode 100644 privacy/java/android/privacy/PrivacySettingsManagerService.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyCursor.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
 create mode 100644 privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
 create mode 100644 services/java/com/android/server/PrivacyTelephonyRegistry.java

diff --git a/Android.mk b/Android.mk
index 946dafe..633dfd1 100644
--- a/Android.mk
+++ b/Android.mk
@@ -214,6 +214,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRemoteControlDisplay.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -314,6 +315,7 @@ aidl_files := \
 	frameworks/base/location/java/android/location/LocationRequest.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderProperties.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderRequest.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
diff --git a/api/current.txt b/api/current.txt
index 7330166..2e26024 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -20687,6 +20687,7 @@ package android.telephony {
   public final class CellInfoGsm extends android.telephony.CellInfo implements android.os.Parcelable {
     method public android.telephony.CellIdentityGsm getCellIdentity();
     method public android.telephony.CellSignalStrengthGsm getCellSignalStrength();
+    method public void setCellIdentity(android.telephony.CellIdentityGsm);
     method public void writeToParcel(android.os.Parcel, int);
     field public static final android.os.Parcelable.Creator CREATOR;
   }
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 1bfc0b2..38c9628 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -116,6 +116,14 @@ import android.accounts.IAccountManager;
 import android.app.admin.DevicePolicyManager;
 import com.android.internal.os.IDropBoxManagerService;
 
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+import android.privacy.surrogate.PrivacyWifiManager;
+import android.privacy.surrogate.PrivacyConnectivityManager;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -184,6 +192,7 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    private static Context sOuterContext = null;
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -299,7 +308,8 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    //Log.d(TAG, "PDroid:ContextImpl: returning PrivacyAccountManager rather than AccountManager");
+                    return new PrivacyAccountManager(ctx, service);
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -338,7 +348,11 @@ class ContextImpl extends Context {
         registerService(CONNECTIVITY_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(CONNECTIVITY_SERVICE);
-                    return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    // SM: Having a 'static outer context' may be problematic if
+                    //     there is more than one instance of this class, ever.
+                    //Log.d(TAG, "PDroid:ContextImpl: returning PrivacyConnectivityManager");
+                    IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
+                    return new PrivacyConnectivityManager(service, getStaticOuterContext());
                 }});
 
         registerService(COUNTRY_DETECTOR, new StaticServiceFetcher() {
@@ -405,7 +419,10 @@ class ContextImpl extends Context {
         registerService(LOCATION_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+                    // SM: I'm not sure whyt this is using getStaticOuterContext rather than getOuterContext.
+                    // Would have thought it should have been the following line:
+                    //Log.d(TAG, "PDroid:ContextImpl: returning PrivacyLocationManager");
+                    return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), getStaticOuterContext());
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -476,7 +493,8 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    //Log.d(TAG, "PDroid:ContextImpl: returning PrivacyTelephonyManager");
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -513,7 +531,8 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(WIFI_SERVICE);
                     IWifiManager service = IWifiManager.Stub.asInterface(b);
-                    return new WifiManager(ctx.getOuterContext(), service);
+                    //Log.d(TAG, "PDroid:ContextImpl: returning PrivacyWifiManager");
+                    return new PrivacyWifiManager(ctx.getOuterContext(), service);
                 }});
 
         registerService(WIFI_P2P_SERVICE, new ServiceFetcher() {
@@ -523,6 +542,14 @@ class ContextImpl extends Context {
                     return new WifiP2pManager(service);
                 }});
 
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    //Log.d(TAG, "PDroid:ContextImpl: Creating static privacy service");
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(), service);
+                }});
+
         registerService(WINDOW_SERVICE, new ServiceFetcher() {
                 public Object getService(ContextImpl ctx) {
                     Display display = ctx.mDisplay;
@@ -1853,7 +1880,10 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        if (sOuterContext != null)
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1870,7 +1900,10 @@ class ContextImpl extends Context {
         mContentResolver = context.mContentResolver;
         mUser = context.mUser;
         mDisplay = context.mDisplay;
-        mOuterContext = this;
+        if (sOuterContext != null)
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+
+        sOuterContext = mOuterContext = this;
     }
 
     static void init(ActivityThread thread) {
@@ -2011,13 +2044,20 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        if (sOuterContext != null)
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index e0856ae..6491ff0 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -48,6 +48,10 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.TelephonyManager;
 
 /**
  * Base class for implementing application instrumentation code.  When running
@@ -88,6 +92,7 @@ public class Instrumentation {
     private boolean mAutomaticPerformanceSnapshots = false;
     private PerformanceCollector mPerformanceCollector;
     private Bundle mPerfMetrics = new Bundle();
+    private PrivacySettingsManager mPrvSvc;
 
     public Instrumentation() {
     }
@@ -1391,6 +1396,77 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity: execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		    if (mPrvSvc != null) {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Obtained privacy service");
+        		    } else {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not obtained");
+        		    }
+        		} else {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Already had privacy service");
+        		}
+        		
+        		if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not available: rejecting call attempt");
+        		    allowIntent = false;
+        		    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+        		} else {
+            		PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+            		if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+            		} else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		} else {
+            		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call denied: Settings deny " + who.getPackageName());
+            		    // No settings = allowed; any phone call setting but real == disallowed
+            		    
+                		allowIntent = false;
+                		
+                		// test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                		// Send the notification intent
+                		final Context tmp = who;
+                		// SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                		new Thread(new Runnable() {
+                		    public void run() {
+                		        // SM: Not clear why there is this delay
+                		    	try{
+                 		    		Thread.sleep(1000); //wait 1 Second
+                 		    	} catch(Exception e){
+                 		    		//nothing here
+                 		    	}  
+                		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                        		Bundle extras = new Bundle();
+                        		extras.putString("packageName", tmp.getPackageName());
+                        		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                        		privacy.putExtras(extras);
+                        		tmp.sendBroadcast(privacy);
+                        		Log.i("PrivacyContext","sent privacy intent");
+                		    }
+                		}).start();
+                		mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		}
+        		}
+            }
+        } catch(Exception e){
+        	 if(who != null) {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for " + who.getPackageName(), e);
+        	 } else {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for unknown package", e);
+        	 }
+        }
+
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1406,6 +1482,14 @@ public class Instrumentation {
                 }
             }
         }
+
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
@@ -1446,6 +1530,109 @@ public class Instrumentation {
             IBinder token, Activity target, Intent[] intents, Bundle options,
             int userId) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+
+        // BEGIN privacy-added
+        
+        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: execStartActivitiesAsUser for " + who.getPackageName());
+        if (intents != null) {
+            boolean checkPrivacySettings = false;
+
+            // If any intents are Intent.ACTION_CALL or Intent.ACTION_DIAL, need to check permissions
+            for (Intent intent : intents) {
+                try {
+                    if (intent.getAction() != null && (
+                            intent.getAction().equals(Intent.ACTION_CALL) ||
+                            intent.getAction().equals(Intent.ACTION_DIAL))) {
+                        checkPrivacySettings = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intents for " + who.getPackageName(), e);
+                    // If an exception occurred, then check the privacy settings as the default action
+                    checkPrivacySettings = true;
+                }
+            }
+
+            if (!checkPrivacySettings) {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: No provided intents triggered checking for " + who.getPackageName());
+            } else {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: One or more intents triggered checking for " + who.getPackageName());
+
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Already had privacy service");
+                }
+
+                boolean allowCallIntents = false; 
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not available - assuming permission denied");
+                    allowCallIntents = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: No settings for package: " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: Settings permit " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents denied: Settings deny " + who.getPackageName());
+                        allowCallIntents = false;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+
+                // If call intents are not allowed, need to regenerate the
+                // intents list to remove call-related intents
+                if (!allowCallIntents) {
+                    List<Intent> filteredIntents = new ArrayList<Intent>(intents.length);
+                    for (Intent intent : intents) {
+                        try {
+                            if (intent.getAction() == null || !(
+                                    intent.getAction().equals(Intent.ACTION_CALL) ||
+                                    intent.getAction().equals(Intent.ACTION_DIAL))) {
+                                filteredIntents.add(intent);
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intent for " + who.getPackageName(), e);
+                        }
+                    }
+                    intents = filteredIntents.toArray(new Intent [filteredIntents.size()]);
+                    
+                    // Send the notification intent
+                    final Context tmp = who;
+                    // SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                    new Thread(new Runnable() {
+                        public void run() {
+                            // SM: Not clear why there is this delay
+                            try{
+                                Thread.sleep(1000); //wait 1 Second
+                            } catch(Exception e){
+                                //nothing here
+                            }  
+                            Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                            Bundle extras = new Bundle();
+                            extras.putString("packageName", tmp.getPackageName());
+                            extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                            privacy.putExtras(extras);
+                            tmp.sendBroadcast(privacy);
+                            Log.i("PrivacyContext","sent privacy intent");
+                        }
+                    }).start();
+                }
+            }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1506,6 +1693,77 @@ public class Instrumentation {
         Context who, IBinder contextThread, IBinder token, Fragment target,
         Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+
+        boolean allowIntent = true;
+        try {
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Already had privacy service");
+                }
+
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    // Wait 1 Second
+                                    Thread.sleep(1000);
+                                } catch(Exception e) {
+                                    // Nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e) {
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for unknown package", e);
+             }
+        }
+
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1522,6 +1780,13 @@ public class Instrumentation {
             }
         }
         try {
+            if (!allowIntent)
+                return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
             int result = ActivityManagerNative.getDefault()
@@ -1566,6 +1831,78 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options, UserHandle user) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Already had privacy service");
+                }
+                
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    Thread.sleep(1000); //wait 1 Second
+                                } catch(Exception e){
+                                    //nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e){
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for unknown package", e);
+             }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1581,6 +1918,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        // END privacy-added
+        
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 9e406d4..9cc7902 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -43,6 +43,7 @@ import android.os.UserHandle;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
+import android.privacy.surrogate.PrivacyContentResolver;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -371,6 +372,8 @@ public abstract class ContentResolver {
             try {
                 qCursor = unstableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                //Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+                qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
             } catch (DeadObjectException e) {
                 // The remote process has died...  but we only hold an unstable
                 // reference though, so we might recover!!!  Let's try!!!!
@@ -382,6 +385,8 @@ public abstract class ContentResolver {
                 }
                 qCursor = stableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                //Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+                qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
             }
             if (qCursor == null) {
                 return null;
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index a300776..0604dc5 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -42,6 +42,24 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.locks.ReentrantLock;
 
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import java.util.Random;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
  * snap pictures, and retrieve frames for encoding for video.  This class is a
@@ -162,6 +180,141 @@ public class Camera {
     private boolean mFaceDetectionRunning = false;
     private Object mAutoFocusCallbackLock = new Object();
 
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final String PRIVACY_TAG = "PM,Camera";
+
+    private Context context;
+
+    private PrivacySettingsManager pSetMan;
+
+    private boolean privacyMode = false;
+
+    private IPackageManager mPm;
+
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName() {
+        try {
+            if (mPm != null) {
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            } else {
+                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            }
+        }
+
+        catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+            return null;
+        }
+    }
+
+    /**
+     * This method returns the fake image which should be in system folder! 
+     * @return byte array of jpeg fake image or null if something went wrong
+     * {@hide}
+     */
+    private byte[] getFakeImage() {
+
+        try {
+            String filepath = "/system/media/PDroid.jpeg";
+            File imagefile = new File(filepath);
+            FileInputStream fis = null;
+            fis = new FileInputStream(imagefile);
+            Bitmap bm = BitmapFactory.decodeStream(fis);
+            ByteArrayOutputStream helper = new ByteArrayOutputStream();  
+            bm.compress(Bitmap.CompressFormat.JPEG, 100 , helper);    
+            return helper.toByteArray();
+        }
+        catch(Exception e) {
+            Log.e(PRIVACY_TAG,"something went wrong with getting the picture!");
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate() {
+        try{
+            context = null;
+            pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+            mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+            privacyMode = true;
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+            privacyMode = false;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+        try{
+    		if (pSetMan != null) {
+                PrivacySettings pSet = null;
+                String[] package_names = getPackageName();
+                int uid = Process.myUid();
+                if (package_names != null) {
+                    for (int i=0;i < package_names.length; i++) {
+                        pSet = pSetMan.getSettings(package_names[i], uid);
+                        // If pSet is null, we allow application to access to mic
+                        if (pSet != null && (pSet.getCameraSetting() != PrivacySettings.REAL))
+                            return IS_NOT_ALLOWED;
+
+                        pSet = null;
+                    }
+                    return IS_ALLOWED;
+                } else {
+                    Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+                    return GOT_ERROR;
+                }
+            } else {
+                Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+                return GOT_ERROR;
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+            return GOT_ERROR;
+        }
+    }
+
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success) {
+        String package_names[] = getPackageName();
+        if(success && package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing camera.");
+        } else if(package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing camera.");
+        }
+    }
+
     /**
      * Broadcast Action:  A new picture is taken by the camera, and the entry of
      * the picture has been added to the media store.
@@ -328,6 +481,9 @@ public class Camera {
         mPostviewCallback = null;
         mZoomListener = null;
 
+        // Privacy init
+        initiate();
+
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
             mEventHandler = new EventHandler(this, looper);
@@ -750,6 +906,23 @@ public class Camera {
 
         @Override
         public void handleMessage(Message msg) {
+            // Privacy
+            boolean access = true;
+            if(!privacyMode)
+                initiate();
+
+            String packageName[] = getPackageName();
+            if(checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+                access = false;
+                dataAccess(false);
+                if(packageName != null)
+                    pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+            } else {
+                dataAccess(true);
+                if(packageName != null)
+                    pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+            }
+
             switch(msg.what) {
             case CAMERA_MSG_SHUTTER:
                 if (mShutterCallback != null) {
@@ -759,13 +932,19 @@ public class Camera {
 
             case CAMERA_MSG_RAW_IMAGE:
                 if (mRawImageCallback != null) {
-                    mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    if(access)
+                        mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    else
+                    mRawImageCallback.onPictureTaken(null, mCamera);//this normally doesn't get a call, because we disabled this receiver in takepicture method!
                 }
                 return;
 
             case CAMERA_MSG_COMPRESSED_IMAGE:
                 if (mJpegCallback != null) {
-                    mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    if(access)
+                        mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    else
+                        mJpegCallback.onPictureTaken(getFakeImage(), mCamera);
                 }
                 return;
 
@@ -783,13 +962,21 @@ public class Camera {
                         // Set to oneshot mode again.
                         setHasPreviewCallback(true, false);
                     }
-                    pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    //pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    if(access)
+                        pCb.onPreviewFrame((byte[])msg.obj, mCamera);//leave the camera the preview frame!
+                    else
+                        pCb.onPreviewFrame(getFakeImage(), mCamera);//here we go testing if it is able to give preview of fake image, if it doesn't work -> pass null
                 }
                 return;
 
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
-                    mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    //mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    if(access)
+                        mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    else
+                        mPostviewCallback.onPictureTaken(getFakeImage(), mCamera);//same as in onpreviewframe -> give test fake image
                 }
                 return;
 
@@ -1077,6 +1264,15 @@ public class Camera {
         mPostviewCallback = postview;
         mJpegCallback = jpeg;
 
+    //check if we are in privacy mode!, this is a to hard method to prevent from making pictures, because camera will freeze!	
+    if (!privacyMode)
+        initiate();
+
+    if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+        mRawImageCallback = null;
+        Log.i(PRIVACY_TAG,"blocked rawImageCallback -> it will never be called!");
+    }
+
         // If callback is not set, do not send me callbacks.
         int msgType = 0;
         if (mShutterCallback != null) {
diff --git a/core/java/android/net/NetworkInfo.java b/core/java/android/net/NetworkInfo.java
index 0b23cb7..a08b975 100644
--- a/core/java/android/net/NetworkInfo.java
+++ b/core/java/android/net/NetworkInfo.java
@@ -166,6 +166,15 @@ public class NetworkInfo implements Parcelable {
     }
 
     /**
+     * SM: I've no idea where this is used
+     * Used for set state to get better working Privacy
+     * @hide
+     */
+    public void setState(State state) {
+       this.mState = state;
+    }
+
+    /**
      * Reports the type of network to which the
      * info in this {@code NetworkInfo} pertains.
      * @return one of {@link ConnectivityManager#TYPE_MOBILE}, {@link
diff --git a/core/java/android/os/SystemProperties.java b/core/java/android/os/SystemProperties.java
index 5a79122..bee453f 100644
--- a/core/java/android/os/SystemProperties.java
+++ b/core/java/android/os/SystemProperties.java
@@ -21,6 +21,19 @@ import java.util.ArrayList;
 
 import android.util.Log;
 
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
 
 /**
  * Gives access to the system properties store.  The system properties
@@ -43,6 +56,112 @@ public class SystemProperties
     private static native void native_set(String key, String def);
     private static native void native_add_change_callback();
 
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final String PRIVACY_TAG = "SystemProperties";
+    private static Context context;
+
+    private static PrivacySettingsManager pSetMan;
+
+    private static boolean privacyMode = false;
+
+    private static IPackageManager mPm;
+
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private static String[] getPackageName() {
+        try {
+            if (mPm != null) {
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            } else {
+                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            }
+        } catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+            return null;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private static void initiate() {
+        try {
+            context = null;
+            pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+            mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+           privacyMode = true;
+        } catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+            privacyMode = false;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private static int checkIfPackagesAllowed() {
+        try {
+            if(pSetMan != null) {
+                PrivacySettings pSet = null;
+                String[] package_names = getPackageName();
+                int uid = Process.myUid();
+                if (package_names != null) {
+                    for (int i=0;i < package_names.length; i++) {
+                        pSet = pSetMan.getSettings(package_names[i], uid);
+                        // If pSet is null, we allow application to access to mic
+                        if (pSet != null && (pSet.getNetworkInfoSetting() != PrivacySettings.REAL))
+                            return IS_NOT_ALLOWED;
+
+                        pSet = null;
+                    }
+                    return IS_ALLOWED;
+                } else {
+                    Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+                    return GOT_ERROR;
+                }
+            } else {
+                Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+                return GOT_ERROR;
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+            return GOT_ERROR;
+        }
+    }
+
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private static void dataAccess(boolean success) {
+        String package_names[] = getPackageName();
+        if (success && package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing networkinfo.");
+        } else if(package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing networkinfo.");
+        }
+    }
+
     /**
      * Get the value for the given key.
      * @return an empty string if the key isn't found
@@ -52,6 +171,16 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+
+        if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA) ||
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)) {
+            initiate();
+            if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+                dataAccess(false);
+                return "";
+            }
+            dataAccess(true);
+        }
         return native_get(key);
     }
 
@@ -64,6 +193,16 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+
+    if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA) ||
+        key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+            initiate();
+            if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+                dataAccess(false);
+                return "";
+            }
+            dataAccess(true);
+        }
         return native_get(key, def);
     }
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 9a98d9d..8af96bc 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -59,6 +59,15 @@ import java.net.URISyntaxException;
 import java.util.HashMap;
 import java.util.HashSet;
 
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.os.Process;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
 /**
  * The Settings provider contains global system-level device preferences.
  */
@@ -3100,6 +3109,46 @@ public final class Settings {
                 }
             }
 
+         // Normally it should work with sNameValueCache.getString instead of sLockSettings
+         if (name.equals(ANDROID_ID)) {
+            initiate();
+
+            try {
+                if (pSetMan == null)
+                    pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                if (mPm == null)
+                    mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                PrivacySettings settings = null;
+                final String[] packages = getPackageName();
+                if (packages != null && packages.length > 0) {
+                    for(int i = 0; i < packages.length; i++) {
+                        settings = pSetMan.getSettings(packages[i]);
+                        if (settings != null && settings.getAndroidIdSetting() != PrivacySettings.REAL) {
+                            String output = settings.getAndroidID();
+                            if (output != null) {
+                                pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, output, null);
+                                return output;
+                            } else {
+                                pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, "q4a5w896ay21dr46", null);
+                                // We can not pull out empty android id, because we get bootloops then
+                                return "q4a5w896ay21dr46";
+                            }
+                        }
+
+                        // Package is allowed to get android id
+                        if (i == packages.length - 1)
+                            pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+                        settings = null;
+                    }
+                } else {
+                    pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                Log.e(PRIVACY_TAG,"Got exception in  getString()");
+            }
+        }
+
             return sNameValueCache.getStringForUser(resolver, name, userHandle);
         }
 
@@ -3401,6 +3450,58 @@ public final class Settings {
             return putStringForUser(cr, name, Float.toString(value), userHandle);
         }
 
+        private static final String PRIVACY_TAG = "PM,SecureSettings";
+        private static Context context;
+
+        private static PrivacySettingsManager pSetMan;
+
+        private static boolean privacyMode = false;
+
+        private static IPackageManager mPm;
+
+        /**
+        * {@hide}
+        * @return package names of current process which is using this object or null if something went wrong
+        */
+        private static String[] getPackageName() {
+            try{
+                if(mPm != null) {
+                    int uid = Process.myUid();
+                    final String[] package_names = mPm.getPackagesForUid(uid);
+                    return package_names;
+                } else {
+                    mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                    int uid = Process.myUid();
+                    final String[] package_names = mPm.getPackagesForUid(uid);
+                    return package_names;
+                }
+            }
+            catch(Exception e) {
+                e.printStackTrace();
+                Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+                return null;
+            }
+        }
+
+        /**
+        * {@hide}
+        * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+        * -> privacyMode = true ok! otherwise false!
+        */
+        private static void initiate() {
+            try {
+                    context = null;
+                    pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                    privacyMode = true;
+            }
+            catch(Exception e) {
+                e.printStackTrace();
+                Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+                privacyMode = false;
+            }
+        }
+
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}
          * instead
diff --git a/core/java/android/speech/srec/MicrophoneInputStream.java b/core/java/android/speech/srec/MicrophoneInputStream.java
index fab77a9..196b769 100644
--- a/core/java/android/speech/srec/MicrophoneInputStream.java
+++ b/core/java/android/speech/srec/MicrophoneInputStream.java
@@ -24,6 +24,17 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.lang.IllegalStateException;
 
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import android.util.Log;
 
 /**
  * PCM input stream from the microphone, 16 bits per sample.
@@ -32,11 +43,117 @@ public final class MicrophoneInputStream extends InputStream {
     static {
         System.loadLibrary("srec_jni");
     }
-    
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final String PRIVACY_TAG = "PM,MicrophoneInputStream";
+    private Context context;
+
+    private PrivacySettingsManager pSetMan;
+
+    private boolean privacyMode = false;
+
+    private IPackageManager mPm;
+
     private final static String TAG = "MicrophoneInputStream";
     private int mAudioRecord = 0;
     private byte[] mOneByte = new byte[1];
-    
+
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName() {
+        try{
+            if (mPm != null) {
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            } else {
+                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            }
+        } catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+            return null;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate() {
+        try {
+            context = null;
+            pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+            mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+            privacyMode = true;
+        } catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+            privacyMode = false;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+        try{
+            if (pSetMan != null) {
+                PrivacySettings pSet = null;
+                String[] package_names = getPackageName();
+                int uid = Process.myUid();
+                if (package_names != null) {
+		        	for (int i=0;i < package_names.length; i++) {
+                        pSet = pSetMan.getSettings(package_names[i], uid);
+                        // If pSet is null, we allow application to access to mic
+                        if (pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL))
+                			return IS_NOT_ALLOWED;
+
+                        pSet = null;
+                    }
+                    return IS_ALLOWED;
+                } else {
+                    Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+                    return GOT_ERROR;
+                }
+            } else {
+                Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+                return GOT_ERROR;
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+            return GOT_ERROR;
+        }
+    }
+
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success) {
+        String package_names[] = getPackageName();
+        if (success && package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+        } else if (package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+                Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+        }
+    }
+
     /**
      * MicrophoneInputStream constructor.
      * @param sampleRate sample rate of the microphone, typically 11025 or 8000.
@@ -44,6 +161,22 @@ public final class MicrophoneInputStream extends InputStream {
      * This determines how long an application may delay before losing data.
      */
     public MicrophoneInputStream(int sampleRate, int fifoDepth) throws IOException {
+
+    if (!privacyMode)
+        initiate();
+
+    if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+        dataAccess(false);
+        String packageName[] = getPackageName();
+        if (packageName != null)
+            pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+        throw new IOException("AudioRecord constructor failed - busy?");
+    }
+    dataAccess(true);
+    String packageName[] = getPackageName();
+    if (packageName != null)
+        pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
+
         mAudioRecord = AudioRecordNew(sampleRate, fifoDepth);
         if (mAudioRecord == 0) throw new IOException("AudioRecord constructor failed - busy?");
         int status = AudioRecordStart(mAudioRecord);
diff --git a/media/java/android/media/AudioRecord.java b/media/java/android/media/AudioRecord.java
index 81e8028..25c32c1 100644
--- a/media/java/android/media/AudioRecord.java
+++ b/media/java/android/media/AudioRecord.java
@@ -29,6 +29,20 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 
+import android.app.ActivityThread;
+import android.app.Application;
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
 /**
  * The AudioRecord class manages the audio resources for Java applications
  * to record audio from the audio input hardware of the platform. This is
@@ -190,6 +204,19 @@ public class AudioRecord
      */
     private int mSessionId = 0;
 
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final String PRIVACY_TAG = "PM,AudioRecord";
+    private Context context;
+
+    private PrivacySettingsManager pSetMan;
+
+    private boolean privacyMode = false;
+
+    private IPackageManager mPm;
+
     //---------------------------------------------------------
     // Constructor, Finalize
     //--------------------
@@ -242,11 +269,108 @@ public class AudioRecord
             return; // with mState == STATE_UNINITIALIZED
         }
 
+        initiate();
+
         mSessionId = session[0];
 
         mState = STATE_INITIALIZED;
     }
 
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName() {
+        try {
+            if (mPm != null) {
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            } else {
+                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                int uid = Process.myUid();
+                String[] package_names = mPm.getPackagesForUid(uid);
+                return package_names;
+            }
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+            return null;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate() {
+        try {
+            context = null;
+            pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+            mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+            privacyMode = true;
+        }
+        catch(Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+            privacyMode = false;
+        }
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+        try {
+            if (pSetMan != null) {
+                PrivacySettings pSet = null;
+                String[] package_names = getPackageName();
+                int uid = Process.myUid();
+                if (package_names != null) {
+                    for (int i=0;i < package_names.length; i++) {
+                        pSet = pSetMan.getSettings(package_names[i], uid);
+                        // If pSet is null, we allow application to access to mic
+                        if (pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)) {
+                            return IS_NOT_ALLOWED;
+                        }
+                        pSet = null;
+                    }
+                    return IS_ALLOWED;
+                } else {
+                    Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+                    return GOT_ERROR;
+                }
+            } else {
+                Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+                return GOT_ERROR;
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+            Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+            return GOT_ERROR;
+        }
+    }
+
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success) {
+    String package_names[] = getPackageName();
+    if (success && package_names != null) {
+        for(int i=0;i<package_names.length;i++)
+            Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+        } else if (package_names != null) {
+            for(int i=0;i<package_names.length;i++)
+            Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+        }
+    }
 
     // Convenience method for the constructor's parameter checks.
     // This is where constructor IllegalArgumentException-s are thrown
@@ -511,10 +635,23 @@ public class AudioRecord
      */
     public void startRecording()
     throws IllegalStateException {
-        if (mState != STATE_INITIALIZED) {
-            throw(new IllegalStateException("startRecording() called on an "
-                    +"uninitialized AudioRecord."));
+        // Now check if everything was ok in constructor!
+        if (!privacyMode)
+            initiate();
+
+        if ((mState != STATE_INITIALIZED) || (checkIfPackagesAllowed() == IS_NOT_ALLOWED)) { //If applicaton is not allowed -> throw exception!
+            dataAccess(false);
+
+            String packageName[] = getPackageName();
+            if (packageName != null)
+                pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));  
+
+            throw(new IllegalStateException("startRecording() called on an "+"uninitialized AudioRecord."));
         }
+        dataAccess(true);
+        String packageName[] = getPackageName();
+        if (packageName != null)
+            pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
 
         // start recording
         synchronized(mRecordingStateLock) {
diff --git a/media/java/android/media/MediaRecorder.java b/media/java/android/media/MediaRecorder.java
index 48bea52..21daa3a 100644
--- a/media/java/android/media/MediaRecorder.java
+++ b/media/java/android/media/MediaRecorder.java
@@ -22,12 +22,25 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 import android.view.Surface;
-
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 
+import android.os.Environment;
+import java.io.FileWriter;
+import java.io.File;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.content.pm.IPackageManager;
+import android.content.Context;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
 /**
  * Used to record audio and video. The recording control is based on a
  * simple state machine (see below).
@@ -91,6 +104,59 @@ public class MediaRecorder
     private OnErrorListener mOnErrorListener;
     private OnInfoListener mOnInfoListener;
 
+
+    /**
+     * Default value of privacy path. You have to add the package name at the end to write file in directory of the app itself
+     */
+    private static final String PRIVACY_PATH_DEF = "/data/data/";
+
+    /**
+     * This variable will be set if user use path to save file. Only if user is not allowed!
+     */
+    private String pPath = null;
+
+    /**
+     * Path where Filedescriptor linked to.
+     */
+    private String pFileDescriptorPath = null;
+
+    /**
+     * This variable will be set if user use FileDescriptor so save file. Only if user is not allowed!
+     */
+    private FileDescriptor pFileDescriptor = null;
+
+    private PrivacyRunner pRunner = null;
+
+    private boolean deletedFile = false;
+
+    private static final int STATE_RECORD_AUDIO = 0;
+    private static final int STATE_RECORD_BOTH = 1;
+    private static final int MODE_RECORD_AUDIO = 2;
+    private static final int MODE_RECORD_BOTH = 3;
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final int MIC_DATA_ACCESS = 10;
+    private static final int BOTH_DATA_ACCESS = 11;
+
+    private static final String PRIVACY_TAG = "PM,MediaRecorder";
+
+    /**
+     * {@hide} This context will ever be null, because we dont need it but pass it to the pSetMan!
+     */
+    private Context context;
+
+    private PrivacySettingsManager pSetMan;
+
+    private IPackageManager mPm;
+
+    private boolean privacyMode = false;
+
+    private boolean stoppedStream = false;
+
+    private int ACTUAL_STATE = STATE_RECORD_AUDIO;
+
     /**
      * Default constructor.
      */
@@ -105,6 +171,8 @@ public class MediaRecorder
             mEventHandler = null;
         }
 
+        initiate();
+
         /* Native setup requires a weak reference to our object.
          * It's easier to create it here than in C++.
          */
@@ -135,9 +203,300 @@ public class MediaRecorder
      * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
      */
     public void setPreviewDisplay(Surface sv) {
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSurface = sv;
     }
 
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /**
+     * PrivacyStop. Should be called within privacyRunner
+     */
+    private void privacyStop(){
+    	try{
+    		stop();
+    	} catch(Exception e){
+    		Log.e(PRIVACY_TAG,"Got exception while trying to call privacyStop()");
+    	}
+    }
+    
+    /**
+     * This method search automatically the current package path and return it. If we haven't found any path, we return the path to SDcard if we are able to write to it.
+     * If we're not able to write to sdCard -> return null
+     * @return internal path to package directory or path to SDCard if package not found and we have rights to save files on SDCard. If something went wrong or we couldn't find
+     * anything of it -> return null
+     */
+    private String getPrivacyPath(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		Log.i(PRIVACY_TAG,"returned file: " + data_name + " for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    		return PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                Log.i(PRIVACY_TAG,"Return filePath:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return sdPath + "/" + data_name;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    /**
+     * This method does exactly what the method getPrivacyPath() does, but it returns an FileDescriptor to path
+     * @return FileDescriptor to privacyFile or null if something went wrong
+     */
+    private FileDescriptor getPrivacyFileDescriptor(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		try{
+    			FileOutputStream fos = new  FileOutputStream(PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			FileDescriptor fD = fos.getFD();
+    			pFileDescriptorPath = PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    			Log.i(PRIVACY_TAG,"returned fileDescriptor for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			return fD;
+    		} catch(Exception e){
+    			Log.e(PRIVACY_TAG,"Got exception while creating fileDescriptor -> return null");
+    			return null;
+    		}
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                FileOutputStream fos = new  FileOutputStream(sdPath + "/" + data_name);
+                FileDescriptor fD = fos.getFD();
+                pFileDescriptorPath = sdPath + "/" + data_name;
+                Log.i(PRIVACY_TAG,"Returned FileDescriptor. Path:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return fD;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @param privacySetting the Mode which has to be tested -> MODE_RECORD_AUDIO, MODE_RECORD_BOTH
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(int privacySetting){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    			switch(privacySetting){
+	    				case MODE_RECORD_AUDIO:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+	    					
+	    				case MODE_RECORD_BOTH:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && ((pSet.getRecordAudioSetting() != PrivacySettings.REAL) || (pSet.getCameraSetting() != PrivacySettings.REAL))){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+					default: return GOT_ERROR;
+	    					
+	    			}
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	//runner = new PrivacyRunner();
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+ 
+     /**
+     * Loghelper method, true = access successful, false = blocked access. 
+     * {@hide}
+     */
+    private void dataAccess(boolean success, int micOrBoth){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		switch(micOrBoth){
+			case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+		
+	}
+	else if(package_names != null){
+		switch(micOrBoth){
+		case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * Defines the audio source. These constants are used with
      * {@link MediaRecorder#setAudioSource(int)}.
@@ -327,6 +686,13 @@ public class MediaRecorder
      * @see android.media.CamcorderProfile
      */
     public void setProfile(CamcorderProfile profile) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         setOutputFormat(profile.fileFormat);
         setVideoFrameRate(profile.videoFrameRate);
         setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
@@ -361,6 +727,13 @@ public class MediaRecorder
      * possible.
      */
     public void setCaptureRate(double fps) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         // Make sure that time lapse is enabled when this method is called.
         setParameter("time-lapse-enable=1");
 
@@ -588,6 +961,13 @@ public class MediaRecorder
      * @param bitRate the video encoding bit rate in bits per second.
      */
     public void setVideoEncodingBitRate(int bitRate) {
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         if (bitRate <= 0) {
             throw new IllegalArgumentException("Video encoding bit rate is not positive");
         }
@@ -628,6 +1008,7 @@ public class MediaRecorder
     {
         mPath = null;
         mFd = fd;
+        deletedFile = false;
     }
 
     /**
@@ -642,6 +1023,7 @@ public class MediaRecorder
     {
         mFd = null;
         mPath = path;
+        deletedFile = false;
     }
 
     // native implementation
@@ -660,6 +1042,56 @@ public class MediaRecorder
      */
     public void prepare() throws IllegalStateException, IOException
     {
+        if(!privacyMode)
+            initiate();
+
+        deletedFile = false;
+        boolean skip = false;
+        switch(ACTUAL_STATE) {
+            case STATE_RECORD_AUDIO:
+                if (checkIfPackagesAllowed(MODE_RECORD_AUDIO) == IS_NOT_ALLOWED) {
+                    String x[] = getPackageName();
+                    if(x != null && x.length > 0)
+                        pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+                    pRunner = new PrivacyRunner();
+                    // Here wo do not need to exchange the path or filedescriptor, because we can interrupt very quick!
+                    // Try very low value
+                    pRunner.setDelay(50);
+                    pRunner.start();
+                    skip = true;
+                }
+                break;
+            case STATE_RECORD_BOTH:
+                if (checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED) {
+                    String x[] = getPackageName();
+                    if (x != null && x.length > 0)
+                        pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, null);
+                    if (mPath != null) {
+                        // Now overwrite path
+                        mPath = getPrivacyPath();
+                    } else if (mFd != null) {
+                        // Now overwrite fileDescriptor
+                        mFd = getPrivacyFileDescriptor();
+                    } else {
+                        // No chance to get it, throw exception
+                        throw new IOException("No valid output file");
+                    }
+                    pRunner = new PrivacyRunner();
+                    // We use default time for video record
+                    pRunner.start();
+                    skip = true;
+                }
+                break;
+        }
+
+        String packageName[] = getPackageName();
+        if (!skip) {
+            if(ACTUAL_STATE == STATE_RECORD_BOTH && packageName != null && packageName.length > 0)
+                pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, null);
+            else if (packageName != null && packageName.length > 0)
+                pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+        }
+
         if (mPath != null) {
             FileOutputStream fos = new FileOutputStream(mPath);
             try {
@@ -713,6 +1145,22 @@ public class MediaRecorder
     public void reset() {
         native_reset();
 
+        if(!deletedFile) {
+           if(mPath != null) {
+                File tmp = new File(mPath);
+                if(tmp.delete())
+                    deletedFile = true;
+            } else if(mFd != null && pFileDescriptorPath != null) {
+                File tmp = new File(pFileDescriptorPath);
+                if(tmp.delete())
+                    deletedFile = true;
+            } else {
+                Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+                deletedFile = false;
+            }
+        }
+        pRunner = null;
+        System.gc();
         // make sure none of the listeners get called anymore
         mEventHandler.removeCallbacksAndMessages(null);
     }
@@ -993,5 +1441,69 @@ public class MediaRecorder
     private native void setParameter(String nameValuePair);
 
     @Override
-    protected void finalize() { native_finalize(); }
+    protected void finalize() {
+        if(!deletedFile) {
+            if(mPath != null) {
+                File tmp = new File(mPath);
+                if (tmp.delete())
+                    deletedFile = true;
+            } else if (mFd != null && pFileDescriptorPath != null) {
+                File tmp = new File(pFileDescriptorPath);
+                if (tmp.delete())
+                    deletedFile = true;
+            } else {
+                Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+                deletedFile = false;
+            }
+        }
+        native_finalize();
+    }
+
+    /**
+    * Helper class to interrupt stream.
+    * @author CollegeDev
+    * {@hide}
+    */
+    private class PrivacyRunner extends Thread {
+        private static final long OFFSET_DELAY = 2500;
+
+        private long delay = OFFSET_DELAY;
+
+        public PrivacyRunner() {
+        }
+
+        public void setDelay(long delay) {
+            this.delay = delay;
+        }
+
+        public long getDelay(){
+            return delay;
+        }
+
+        @Override
+        public void run() {
+            try {
+                Thread.sleep(delay);
+                // Now we're going to stop stream
+                privacyStop();
+                if (mPath != null) {
+                    File tmp = new File(mPath);
+                    if (tmp.delete())
+                        deletedFile = true;
+                } else if (mFd != null && pFileDescriptorPath != null) {
+                    File tmp = new File(pFileDescriptorPath);
+                    if (tmp.delete())
+                        deletedFile = true;
+                } else {
+                    Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+                    deletedFile = false;
+                }
+            } catch(Exception e) {
+                Log.e(PRIVACY_TAG,"Something went wrong while waiting for cancel the stream!");
+                e.printStackTrace();
+            } finally{
+                privacyStop();
+            }
+        }
+    }
 }
diff --git a/preloaded-classes b/preloaded-classes
index ca238c8..8f51776 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -2,6 +2,19 @@
 # Automatically generated by frameworks/base/tools/preload/WritePreloadedClassFile.java.
 # MIN_LOAD_TIME_MICROS=1250
 # MIN_PROCESSES=10
+
+android.privacy.PrivacySettingsManagerService
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+android.privacy.PrivacyPersistenceAdapter
+android.privacy.IPrivacySettingsManager
+android.privacy.surrogate.PrivacyActivityManagerService
+android.privacy.surrogate.PrivacyCDMALTEPhone
+android.privacy.surrogate.PrivacyCDMAPhone
+android.privacy.surrogate.PrivacyGSMPhone
+android.privacy.surrogate.PrivacyPhoneProxy
+android.privacy.surrogate.PrivacySipPhone
+
 android.R$styleable
 android.accounts.Account
 android.accounts.Account$1
diff --git a/privacy/java/android/privacy/IPrivacySettingsManager.aidl b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
new file mode 100644
index 0000000..e67230e
--- /dev/null
+++ b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
@@ -0,0 +1,30 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    double getVersion();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+}
diff --git a/privacy/java/android/privacy/PrivacyFileObserver.java b/privacy/java/android/privacy/PrivacyFileObserver.java
new file mode 100644
index 0000000..c02947c
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyFileObserver.java
@@ -0,0 +1,125 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/** {@hide} */
+public final class PrivacyFileObserver extends FileObserver {
+
+	public static final String TAG = "PrivacyFileObserver";
+	public static final int PACKAGE_PATH_INDEX = 3;
+	public static final int SETTINGS_TYPE_INDEX = PACKAGE_PATH_INDEX + 1;
+
+	public String absolutePath;
+	private PrivacySettingsManagerService pSetManServ;
+
+	public HashMap<String, PrivacyFileObserver> children;
+
+	public PrivacyFileObserver(String path,
+			PrivacySettingsManagerService pSetManServ) {
+		super(path, FileObserver.ALL_EVENTS);
+		this.absolutePath = path;
+		this.pSetManServ = pSetManServ;
+
+		this.children = new HashMap<String, PrivacyFileObserver>();
+		File thisFile = new File(absolutePath);
+		if (thisFile.isDirectory()) {
+			File[] subfiles = thisFile.listFiles();
+			for (File file : subfiles) {
+				String observePath = file.getAbsolutePath();
+				PrivacyFileObserver child = new PrivacyFileObserver(
+						observePath, pSetManServ);
+				children.put(observePath, child);
+				// don't watch directories, only the settings files
+				if (file.isFile())
+					child.startWatching();
+			}
+		}
+
+	}
+
+	@Override
+	public void onEvent(int event, String path) {
+		if ((FileObserver.ACCESS & event) != 0) { // data was read from a file
+		// Log.d(TAG, "onEvent - file accessed: " + absolutePath);
+			StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+			for (int i = 0; i < PACKAGE_PATH_INDEX
+					&& tokenizer.hasMoreElements(); i++) {
+				tokenizer.nextToken();
+			}
+
+			// get the package and UID of accessing application
+			String packageName = tokenizer.nextToken();
+			String settingsType = null;
+			if (tokenizer.hasMoreElements())
+				settingsType = tokenizer.nextToken();
+			// int uid = 0;
+			// try {
+			// uid = Integer.parseInt(tokenizer.nextToken());
+			// } catch (NumberFormatException e) {
+			// Log.e(TAG,
+			// "onEvent - could not get the UID of accessing application", e);
+			// // we still can continue, UID is optional here
+			// }
+
+			// read the setting
+			try {
+				if (settingsType != null
+						&& settingsType.equals("ipTableProtectSetting")) {
+					PrivacySettings pSet = pSetManServ.getSettings(packageName);
+					pSetManServ.notification(packageName,
+							pSet.getIpTableProtectSetting(),
+							PrivacySettings.DATA_IP_TABLES, null);
+				} else {
+					PrivacySettings pSet = pSetManServ.getSettings(packageName);
+					pSetManServ.notification(packageName,
+							pSet.getSystemLogsSetting(),
+							PrivacySettings.DATA_SYSTEM_LOGS, null);
+				}
+			} catch (Exception e) {
+				// nothing here
+			}
+		}
+
+	}
+
+	public void addObserver(String relativePath) {
+		String observePath = absolutePath + "/" + relativePath;
+		// remove existing observer(s) if any
+		children.remove(observePath); // child observers should be destroyed at
+										// next GC
+		// create new observer(s)
+		PrivacyFileObserver child = new PrivacyFileObserver(observePath,
+				pSetManServ);
+		children.put(observePath, child);
+	}
+
+	@Override
+	public void startWatching() {
+		// Log.d("PrivacyFileObserver",
+		// "PrivacyFileObserver - observing directory: " + absolutePath);
+		super.startWatching();
+	}
+
+	// public void verifyObserver() {
+	// Log.d(TAG, "verifyObservers - observer path: " + absolutePath);
+	// for (PrivacyFileObserver obs : children.values()) obs.verifyObserver();
+	// }
+
+}
diff --git a/privacy/java/android/privacy/PrivacyPersistenceAdapter.java b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
new file mode 100644
index 0000000..621bc1f
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
@@ -0,0 +1,1036 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * 
+ * @author Svyatoslav Hresyk {@hide}
+ */
+public final class PrivacyPersistenceAdapter {
+
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    private static final int RETRY_QUERY_COUNT = 5;
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    private static final int DATABASE_VERSION = 4;
+    private static final boolean LOG_LOCKING = false;
+    public static final int DUMMY_UID = -1;
+
+    /**
+     * Number of threads currently reading the database Could probably be
+     * improved by using 'AtomicInteger'
+     */
+    public static volatile Integer sDbAccessThreads = 0;
+    public static volatile int sDbVersion;
+
+    // Used to lock the database during multi-statement operations to prevent
+    // internally inconsistent data reads.
+    // Multiple locks could be used to improve efficiency (i.e. for different tables)
+    private static ReadWriteLock sDbLock = new ReentrantReadWriteLock();
+
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+
+    private static final String TABLE_SETTINGS = "settings";
+    private static final String TABLE_MAP = "map";
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    private static final String TABLE_VERSION = "version";
+
+    private static final String CREATE_TABLE_SETTINGS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " + 
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " + 
+        " packageName TEXT, " + 
+        " uid INTEGER, " + 
+        " deviceIdSetting INTEGER, " + 
+        " deviceId TEXT, " + 
+        " line1NumberSetting INTEGER, " + 
+        " line1Number TEXT, " + 
+        " locationGpsSetting INTEGER, " + 
+        " locationGpsLat TEXT, " + 
+        " locationGpsLon TEXT, " + 
+        " locationNetworkSetting INTEGER, " + 
+        " locationNetworkLat TEXT, " + 
+        " locationNetworkLon TEXT, " + 
+        " networkInfoSetting INTEGER, " + 
+        " simInfoSetting INTEGER, " + 
+        " simSerialNumberSetting INTEGER, " + 
+        " simSerialNumber TEXT, " + 
+        " subscriberIdSetting INTEGER, " + 
+        " subscriberId TEXT, " + 
+        " accountsSetting INTEGER, " + 
+        " accountsAuthTokensSetting INTEGER, " + 
+        " outgoingCallsSetting INTEGER, " + 
+        " incomingCallsSetting INTEGER, " + 
+        " contactsSetting INTEGER, " + 
+        " calendarSetting INTEGER, " + 
+        " mmsSetting INTEGER, " + 
+        " smsSetting INTEGER, " + 
+        " callLogSetting INTEGER, " + 
+        " bookmarksSetting INTEGER, " + 
+        " systemLogsSetting INTEGER, " + 
+        " externalStorageSetting INTEGER, " + 
+        " cameraSetting INTEGER, " + 
+        " recordAudioSetting INTEGER, " + 
+        " notificationSetting INTEGER, " + 
+        " intentBootCompletedSetting INTEGER," + 
+        " smsSendSetting INTEGER," + 
+        " phoneCallSetting INTEGER," +
+        " ipTableProtectSetting INTEGER," +
+        " iccAccessSetting INTEGER," +
+        " addOnManagementSetting INTEGER," + //this setting indicate if app is managed by addon or not
+        " androidIdSetting INTEGER," +
+        " androidId TEXT," +
+        " wifiInfoSetting INTEGER," +
+        " switchConnectivitySetting INTEGER," +
+        " sendMmsSetting INTEGER," +
+        " forceOnlineState INTEGER," + 
+        " switchWifiStateSetting INTEGER" +
+        ");";
+    
+
+    private static final String CREATE_TABLE_MAP = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+
+    private static final String INSERT_VERSION = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+
+    private static final String INSERT_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+
+    private static final String INSERT_NOTIFICATIONS_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid",
+            "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number",
+            "locationGpsSetting", "locationGpsLat", "locationGpsLon", "locationNetworkSetting",
+            "locationNetworkLat", "locationNetworkLon", "networkInfoSetting", "simInfoSetting",
+            "simSerialNumberSetting", "simSerialNumber", "subscriberIdSetting", "subscriberId",
+            "accountsSetting", "accountsAuthTokensSetting", "outgoingCallsSetting",
+            "incomingCallsSetting", "contactsSetting", "calendarSetting", "mmsSetting",
+            "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting",
+            "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting",
+            "intentBootCompletedSetting", "smsSendSetting", "phoneCallSetting",
+            "ipTableProtectSetting", "iccAccessSetting", "addOnManagementSetting",
+            "androidIdSetting", "androidId", "wifiInfoSetting", "switchConnectivitySetting",
+            "sendMmsSetting", "forceOnlineState", "switchWifiStateSetting" };
+
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase mDb;
+
+    private Context mContext;
+
+    public PrivacyPersistenceAdapter(Context context) {
+        this.mContext = context;
+
+        // create the database and settings directory if we have write
+        // permission and they do not exist
+        if (new File("/data/system/").canWrite()) { 
+            if (!(new File(DATABASE_FILE).exists() && new File(SETTINGS_DIRECTORY).exists())) {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (pre)lock");
+                sDbLock.writeLock().lock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (post)lock");
+                try {
+                    if (!new File(DATABASE_FILE).exists()) {
+                        createDatabase();
+                    }
+                    if (!new File(SETTINGS_DIRECTORY).exists()) {
+                        createSettingsDir();
+                    }
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (pre)unlock");
+                    sDbLock.writeLock().unlock();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (post)unlock");
+                }
+            }
+
+
+            // upgrade if needed
+            sDbVersion = getDbVersion();
+            
+            if (sDbVersion < DATABASE_VERSION) {
+                upgradeDatabase();
+            }
+        }
+    }
+
+
+    private void upgradeDatabase() {
+        if (sDbVersion < DATABASE_VERSION) {
+            Log.i(TAG, "PrivacyPersistenceAdapter:upgradeDatabase - upgrading DB from version " + sDbVersion + " to "
+                    + DATABASE_VERSION);
+
+            SQLiteDatabase db = null;
+            
+            switch (sDbVersion) {
+            case 1:
+            case 2:
+            case 3:
+                try {
+                    synchronized (sDbAccessThreads) {
+                        sDbAccessThreads++;
+                    }
+
+                    db = getDatabase();
+                    if (db != null && db.isOpen()) {
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (pre)lock");
+                        sDbLock.writeLock().lock();
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (post)lock");
+                        
+                        try {
+                            // check the db version again to make sure that another thread has not already done the upgrade
+                            // in the meantime
+                            if (sDbVersion < DATABASE_VERSION) {                                
+                                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (pre)begin");
+                                db.beginTransaction();
+                                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (post)begin");
+
+                                try {
+                                    db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                                    db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+                                    db.execSQL(CREATE_TABLE_MAP);
+                                    db.execSQL(INSERT_VERSION);
+                                    db.execSQL(INSERT_ENABLED);
+                                    db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+
+                                    purgeSettings();
+                                    
+                                    // remove uid dirs from the settings directory
+                                    // TODO: improve handling so that if an exception happens while
+                                    //      this process is in progress, it doesn't leave the filesystem
+                                    //      entries in an invalid state
+                                    File settingsDir = new File(SETTINGS_DIRECTORY);
+                                    for (File packageDir : settingsDir.listFiles()) {
+                                        for (File uidDir : packageDir.listFiles()) {
+                                            if (uidDir.isDirectory()) {
+                                                File[] settingsFiles = uidDir.listFiles();
+                                                // copy the first found (most likely
+                                                // the only one) one level up
+                                                if (settingsFiles[0] != null) {
+                                                    File newPath = new File(packageDir + "/"
+                                                            + settingsFiles[0].getName());
+                                                    newPath.delete();
+                                                    settingsFiles[0].renameTo(newPath);
+                                                    deleteRecursive(uidDir);
+                                                }
+                                            }
+                                        }
+                                    }
+    
+                                    db.setTransactionSuccessful();
+                                    sDbVersion = DATABASE_VERSION;
+                                } finally {                                
+                                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (pre)end");
+                                    db.endTransaction();
+                                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (post)end");
+                                }
+                            } else {
+                                // The database has been upgraded elsewhere; end the db transaction
+                                // and don't make any further changes
+                            }
+                                
+                        } finally {
+                            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (pre)unlock");
+                            sDbLock.writeLock().unlock();
+                            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (post)unlock");
+                        }
+                    }
+                } catch (SQLException e) {
+                    Log.e(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: SQLException occurred performing database upgrade", e);
+                } finally {
+                    closeIdleDatabase();
+                }
+                break;
+
+            case 4:
+                // most current version, do nothing
+                Log.i(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Database is already at the most recent version");
+                break;
+            }
+        }
+    }
+
+    
+    private int getDbVersion() {
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:getDbVersion: getValue returned null; assuming version = 1");
+            return 1;
+        } else {
+            try {
+                return Integer.parseInt(versionString);
+            } catch (Exception e) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getDbVersion: failed to parse database version; returning 1");
+                return 1;
+            }
+        }
+    }
+
+    
+    public String getValue(String name) {
+        SQLiteDatabase db;
+        Cursor c;
+        String output = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            db = getDatabase();
+            if (db == null || !db.isOpen()) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getValue: Database not obtained while getting value for name: " + name);
+                return null;
+            }
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (pre)lock");
+            sDbLock.readLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (post)lock");
+            try {
+
+                c = query(db, TABLE_MAP, new String[] { "value" }, "name=?", new String[] { name },
+                        null, null, null, null);
+                if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                    output = c.getString(c.getColumnIndex("value"));
+                    c.close();
+                } else {
+                    Log.w(TAG, "PrivacyPersistenceAdapter:getValue: Could not get value for name: " + name);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getValue: Exception occurred while getting value for name: " + name, e);
+            } finally {
+                
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (pre)unlock");
+                sDbLock.readLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (post)unlock");
+            }
+
+        } finally {
+            closeIdleDatabase();
+        }
+        return output;
+    }
+    
+    public boolean setValue(String name, String value) {
+        Log.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+
+        boolean success = false;
+
+        SQLiteDatabase db;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            db = getDatabase();
+            if (db == null || !db.isOpen()) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:setValue: Database not obtained while setting value for name: " + name);
+                return false;
+            }
+            
+            // updating the version is atomic, but we need to use a lock
+            // to make sure we don't try to get/update the version while the DB is being created or upgraded
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (post)lock");
+            try {
+                success = db.replace(TABLE_MAP, null, values) != -1;
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (post)unlock");
+            }
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return success;
+    }
+    
+    /**
+     * Retrieve privacy settings for a single package
+     * 
+     * @param packageName
+     *            package for which to retrieve settings
+     * @return privacy settings for the package, or null if no settings exist
+     *         for it
+     */
+    public PrivacySettings getSettings(String packageName) {
+        PrivacySettings privacySettings = null;
+
+        if (packageName == null) {
+            throw new InvalidParameterException(
+                    "PrivacyPersistenceAdapter:getSettings:insufficient application identifier - package name is required");
+        }
+
+        SQLiteDatabase db;
+        try {
+            // indicate that the DB is being read to prevent closing by other threads
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            db = getDatabase();
+        } catch (SQLiteException e) {
+            Log.e(TAG, "getSettings - database could not be opened", e);
+            closeIdleDatabase();
+            return privacySettings;
+        }
+
+        Cursor cursor = null;
+
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (pre)lock");
+        sDbLock.readLock().lock();
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (post)lock");
+        try {
+            cursor = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?",
+                    new String[] { packageName }, null, null, null, null);
+
+            if (cursor != null) {
+                if (cursor.getCount() != 1) {
+                    Log.w(TAG, "Multiple privacy settings found for package " + packageName);
+                }
+                if (cursor.moveToFirst()) {
+                    privacySettings = new PrivacySettings(cursor.getInt(0), cursor.getString(1),
+                            cursor.getInt(2), (byte) cursor.getShort(3), cursor.getString(4),
+                            (byte) cursor.getShort(5), cursor.getString(6),
+                            (byte) cursor.getShort(7), cursor.getString(8), cursor.getString(9),
+                            (byte) cursor.getShort(10), cursor.getString(11), cursor.getString(12),
+                            (byte) cursor.getShort(13), (byte) cursor.getShort(14),
+                            (byte) cursor.getShort(15), cursor.getString(16),
+                            (byte) cursor.getShort(17), cursor.getString(18),
+                            (byte) cursor.getShort(19), (byte) cursor.getShort(20),
+                            (byte) cursor.getShort(21), (byte) cursor.getShort(22),
+                            (byte) cursor.getShort(23), (byte) cursor.getShort(24),
+                            (byte) cursor.getShort(25), (byte) cursor.getShort(26),
+                            (byte) cursor.getShort(27), (byte) cursor.getShort(28),
+                            (byte) cursor.getShort(29), (byte) cursor.getShort(30),
+                            (byte) cursor.getShort(31), (byte) cursor.getShort(32),
+                            (byte) cursor.getShort(33), (byte) cursor.getShort(34), null,
+                            (byte) cursor.getShort(35), (byte) cursor.getShort(36),
+                            (byte) cursor.getShort(37), (byte) cursor.getShort(38),
+                            (byte) cursor.getShort(39), (byte) cursor.getShort(40),
+                            cursor.getString(41), (byte) cursor.getShort(42),
+                            (byte) cursor.getShort(43), (byte) cursor.getShort(44),
+                            (byte) cursor.getShort(45), (byte) cursor.getShort(46));
+
+                    // get allowed contacts IDs if necessary
+                    cursor = query(db, TABLE_ALLOWED_CONTACTS, new String[] { "contact_id" },
+                            "settings_id=?",
+                            new String[] { Integer.toString(privacySettings.get_id()) }, null,
+                            null, null, null);
+
+                    if (cursor != null && cursor.getCount() > 0) {
+                        int[] allowedContacts = new int[cursor.getCount()];
+                        while (cursor.moveToNext())
+                            allowedContacts[cursor.getPosition()] = cursor.getInt(0);
+                        privacySettings.setAllowedContacts(allowedContacts);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+        } finally {
+            if (cursor != null)
+                cursor.close();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (pre)unlock");
+            sDbLock.readLock().unlock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (post)unlock");
+            closeIdleDatabase();
+        }
+
+        return privacySettings;
+    }
+
+    /**
+     * Saves the settings object fields into DB and into plain text files where
+     * applicable. The DB changes will not be made persistent if saving settings
+     * to plain text files fails.
+     * 
+     * @param s
+     *            settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public boolean saveSettings(PrivacySettings s) {
+        boolean result = false;
+
+        String packageName = s.getPackageName();
+
+        if (packageName == null || packageName.isEmpty()) {
+            Log.e(TAG, "saveSettings - either package name is missing");
+            return false;
+        }
+
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+        // values.put("uid", uid);
+        values.put("uid", DUMMY_UID);
+
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());
+        values.put("simInfoSetting", s.getSimInfoSetting());
+
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());
+        values.put("subscriberId", s.getSubscriberId());
+
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+        // values.put("externalStorageSetting", s.getExternalStorageSetting());
+        values.put("cameraSetting", s.getCameraSetting());
+        values.put("recordAudioSetting", s.getRecordAudioSetting());
+        values.put("smsSendSetting", s.getSmsSendSetting());
+        values.put("phoneCallSetting", s.getPhoneCallSetting());
+        values.put("ipTableProtectSetting", s.getIpTableProtectSetting());
+        values.put("iccAccessSetting", s.getIccAccessSetting());
+        values.put("addOnManagementSetting", s.getAddOnManagementSetting());
+        values.put("androidIdSetting", s.getAndroidIdSetting());
+        values.put("androidId", s.getAndroidID());
+        values.put("wifiInfoSetting", s.getWifiInfoSetting());
+        values.put("switchConnectivitySetting", s.getSwitchConnectivitySetting());
+        values.put("sendMmsSetting", s.getSendMmsSetting());
+        values.put("forceOnlineState", s.getForceOnlineState());
+        values.put("switchWifiStateSetting", s.getSwitchWifiStateSetting());
+
+        SQLiteDatabase db = null;
+        Cursor cursor = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            db = getDatabase();
+
+            if (db != null && db.isOpen()) {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (pre)lock");
+                sDbLock.writeLock().lock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (post)lock");
+                try {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (pre)begin");
+                    db.beginTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (post)begin");
+                    try {
+
+                        // save settings to the DB
+                        Integer id = s.get_id();
+
+                        if (id != null) { // existing entry -> update
+                            if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                                throw new Exception("saveSettings - failed to update database entry");
+                            }
+
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", id);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                        throw new Exception(
+                                                "PrivacyPersistenceAdapter:saveSettings: failed to update database entry (contacts)");
+                                }
+                            }
+
+                        } else { // new entry -> insert if no duplicates exist
+                            // Log.d(TAG,
+                            // "saveSettings - new entry; verifying if duplicates exist");
+                            cursor = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                                    new String[] { s.getPackageName() }, null, null, null);
+
+                            if (cursor != null) {
+                                if (cursor.getCount() == 1) { // exactly one entry
+                                    // exists -> update
+                                    // Log.d(TAG, "saveSettings - updating existing entry");
+                                    if (db.update(TABLE_SETTINGS, values, "packageName=?",
+                                            new String[] { s.getPackageName() }) < 1) {
+                                        throw new Exception("saveSettings - failed to update database entry");
+                                    }
+
+                                    if (cursor.moveToFirst()) {
+                                        Integer idAlt = cursor.getInt(0); // id of the found
+                                        // duplicate entry
+                                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                                new String[] { idAlt.toString() });
+                                        int[] allowedContacts = s.getAllowedContacts();
+                                        if (allowedContacts != null) {
+                                            ContentValues contactsValues = new ContentValues();
+                                            for (int i = 0; i < allowedContacts.length; i++) {
+                                                contactsValues.put("settings_id", idAlt);
+                                                contactsValues.put("contact_id", allowedContacts[i]);
+                                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                                    throw new Exception(
+                                                            "saveSettings - failed to update database entry (contacts)");
+                                            }
+                                        }
+                                    }
+                                } else if (cursor.getCount() == 0) { // no entries -> insert
+                                    // Log.d(TAG, "saveSettings - inserting new entry");
+                                    long rowId = db.insert(TABLE_SETTINGS, null, values);
+                                    if (rowId == -1) {
+                                        throw new Exception(
+                                                "PrivacyPersistenceAdapter:saveSettings - failed to insert new record into DB");
+                                    }
+
+                                    db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                            new String[] { Long.toString(rowId) });
+                                    int[] allowedContacts = s.getAllowedContacts();
+                                    if (allowedContacts != null) {
+                                        ContentValues contactsValues = new ContentValues();
+                                        for (int i = 0; i < allowedContacts.length; i++) {
+                                            contactsValues.put("settings_id", rowId);
+                                            contactsValues.put("contact_id", allowedContacts[i]);
+                                            if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                                throw new Exception(
+                                                        "PrivacyPersistenceAdapter:saveSettings:failed to update database entry (contacts)");
+                                        }
+                                    }
+                                } else {
+                                    // something went totally wrong and there are
+                                    // multiple entries for same identifier
+                                    throw new Exception("PrivacyPersistenceAdapter:saveSettings:duplicate entries in the privacy.db");
+                                }
+                            } else {
+                                // jump to catch block to avoid marking transaction as
+                                // successful
+                                throw new Exception("PrivacyPersistenceAdapter:saveSettings:cursor is null, database access failed");
+                            }
+                        }
+
+                        // save settings to plain text file (for access from core libraries)
+                        if (!writeExternalSettings("systemLogsSetting", packageName, s)) {
+                            throw new Exception("PrivacyPersistenceAdapter:saveSettings:failed to write systemLogsSettings file");
+                        }
+                        if (!writeExternalSettings("ipTableProtectSetting", packageName, s)) {
+                            throw new Exception("PrivacyPersistenceAdapter:saveSettings:failed to write ipTableProtectSetting file");
+                        }
+
+                        // mark DB transaction successful (commit the changes)
+                        db.setTransactionSuccessful();
+                    } finally {
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (pre)end");
+                        db.endTransaction(); // we want to transition from set transaction successful to end as fast as possible to avoid errors (see the Android docs)
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (post)end");
+                        
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (pre)unlock");
+                    sDbLock.writeLock().unlock();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (post)unlock");
+                }
+                result = true;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:saveSettings: saving for " + packageName + " failed", e);
+        } finally {
+            closeIdleDatabase();
+        }
+
+    return result;
+}
+
+    /**
+     * This method creates external settings files for access from core libraries
+     * 
+     * @param settingsName
+     *            field name from database
+     * @param packageName
+     *            name of package
+     * @param s
+     *            settings from package
+     * @return true if file was successful written
+     * @throws Exception
+     *             if we cannot write settings to directory
+     */
+    private boolean writeExternalSettings(String settingsName, String packageName, PrivacySettings s)
+            throws Exception {
+        // save settings to plain text file (for access from core libraries)
+        File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+        File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/"
+                + settingsName);
+        boolean result = false;
+        
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (pre)lock");
+        sDbLock.writeLock().lock();
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (post)lock");
+        try {
+            settingsPackageDir.mkdirs();
+            settingsPackageDir.setReadable(true, false);
+            settingsPackageDir.setExecutable(true, false);
+            // create the setting files and make them readable
+            systemLogsSettingFile.createNewFile();
+            systemLogsSettingFile.setReadable(true, false);
+            // write settings to files
+            // Log.d(TAG, "saveSettings - writing to file");
+            OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(
+                    systemLogsSettingFile));
+            // now decide which feature of setting we have to save
+            if (settingsName.equals("systemLogsSetting"))
+                writer.append(s.getSystemLogsSetting() + "");
+            else if (settingsName.equals("ipTableProtectSetting"))
+                writer.append(s.getIpTableProtectSetting() + "");
+            writer.flush();
+            writer.close();
+            result = true;
+        } catch (IOException e) {
+            // jump to catch block to avoid marking transaction as successful
+            throw new Exception("saveSettings - could not write settings to file", e);
+        } finally {
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (pre)unlock");
+            sDbLock.writeLock().unlock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (post)unlock");
+        }
+        
+        return true;
+    }
+
+    /**
+     * Deletes a settings entry from the DB
+     * 
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public boolean deleteSettings(String packageName) {
+        boolean result = true;
+
+        SQLiteDatabase db = null;
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+
+            db = getDatabase();
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (post)lock");
+            try {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (pre)begin");
+                db.beginTransaction();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (post)begin");
+                // make sure this ends up in a consistent state
+                try {
+                    // try deleting contacts allowed entries; do not fail if deletion
+                    // not possible
+                    // TODO: restructure this into a more efficient query (ideally a
+                    // single query without a cursor)
+                    Cursor c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                            new String[] { packageName }, null, null, null);
+
+
+                    if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                        int id = c.getInt(0);
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                new String[] { Integer.toString(id) });
+                        c.close();
+                    } else {
+                        Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                    }
+
+                    if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                        Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                    }
+
+                    // delete settings from plain text file (for access from core
+                    // libraries)
+                    File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+                    File systemLogsSettingFile = new File("/data/system/privacy/" + packageName
+                            + "/systemLogsSetting");
+
+                    // delete the setting files
+                    systemLogsSettingFile.delete();
+                    // delete the parent directories
+                    if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0)
+                        settingsPackageDir.delete();
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (pre)end");
+                    db.endTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (post)end");
+                }
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (post)unlock");
+            }
+        } catch (SQLiteException e) {
+            result = false;
+            Log.e(TAG, "PrivacyPersistenceAdapter:deleteSettings: failed to open the database, or open a transaction", e);
+        } catch (Exception e) {
+            result = false;
+            Log.e(TAG, "PrivacyPersistenceAdapter:deleteSettings - could not delete settings", e);
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return result;
+    }
+
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection,
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit)
+            throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of
+        // IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null)
+                    c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy,
+                        limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen())
+                    db.close();
+                db = getDatabase();
+            }
+        }
+        if (success == false)
+            throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of
+        // IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null)
+                    c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen())
+                    db.close();
+                db = getDatabase();
+            }
+        }
+        if (success == false)
+            throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used
+     * in methods, which rely on the DB being open after this method has
+     * finished. It will close the DB if no other threads has increased the
+     * readingThread count.
+     * 
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+
+        // get installed apps
+        Set<String> apps = new HashSet<String>();
+        PackageManager pMan = mContext.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(0);
+        for (ApplicationInfo appInfo : installedApps) {
+            apps.add(appInfo.packageName);
+        }
+
+        SQLiteDatabase db = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+
+            // delete obsolete entries from DB and update outdated entries
+            db = getDatabase();
+            if (db == null) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:purgeSettings: db could not be obtained");
+                return false;
+            }
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (post)lock");
+            try {
+                Cursor cursor = null;
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (pre)begin");
+                db.beginTransaction();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (post)begin");
+                try {
+                    cursor = query(db, TABLE_SETTINGS, new String[] { "packageName" }, null, null, null, null,
+                            null, null);
+                    if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
+                        do {
+                            String packageName = cursor.getString(0);
+                            if (!apps.contains(packageName)) {
+                                db.delete(TABLE_SETTINGS, "packageName = ?", new String [] { packageName });
+                            }
+                        } while (cursor.moveToNext());
+                    }
+
+                    // delete obsolete settings directories
+                    File settingsDir = new File(SETTINGS_DIRECTORY);
+                    for (File packageDir : settingsDir.listFiles()) {
+                        String packageName = packageDir.getName();
+                        if (!apps.contains(packageName)) { // remove package dir if no such
+                            // app installed
+                            deleteRecursive(packageDir);
+                        }
+                    }
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (pre)end");
+                    db.endTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (post)end");
+                }
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (post)unlock");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:purgeSettings - purging DB failed", e);
+            result = false;
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return result;
+    }
+    
+
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles())
+                deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+
+    private void createDatabase() {
+        Log.i(TAG, "createDatabase - creating privacy database file");
+        try {
+            SQLiteDatabase db = SQLiteDatabase.openDatabase(DATABASE_FILE, null,
+                    SQLiteDatabase.OPEN_READWRITE | SQLiteDatabase.CREATE_IF_NECESSARY);
+            Log.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+            // Log.d(TAG, "createDatabase - closing connection to privacy.db");
+            if (db != null && db.isOpen())
+                db.close();
+        } catch (SQLException e) {
+            Log.e(TAG, "createDatabase - failed to create privacy database", e);
+        }
+    }
+
+    private void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+
+    private synchronized SQLiteDatabase getDatabase() {
+        if (mDb == null || !mDb.isOpen() || mDb.isReadOnly()) {
+            mDb = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+        }   
+        return mDb;
+    }
+
+    /**
+     * If there are no more threads reading the database, close it. Otherwise,
+     * reduce the number of reading threads by one
+     */
+    private void closeIdleDatabase() {
+        synchronized (sDbAccessThreads) {
+            sDbAccessThreads--;
+            // only close DB if no other threads are reading
+            if (sDbAccessThreads == 0 && mDb != null && mDb.isOpen()) {
+                mDb.close();
+            }
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettings.aidl b/privacy/java/android/privacy/PrivacySettings.aidl
new file mode 100644
index 0000000..c114960
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.aidl
@@ -0,0 +1,16 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff --git a/privacy/java/android/privacy/PrivacySettings.java b/privacy/java/android/privacy/PrivacySettings.java
new file mode 100644
index 0000000..e218102
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.java
@@ -0,0 +1,1027 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk 
+ * {@hide} 
+ */
+public final class PrivacySettings implements Parcelable {
+    
+    /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+    
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+    
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings, 
+     * it is setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+    
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     * 
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+    
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+    
+    /** used to create random android ID*/
+    public static final String[] ID_PATTERN = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
+    
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+//    public static final String DATA_EXTERNAL_STORAGE = "externalStorage";
+    public static final String DATA_CAMERA = "camera";
+    public static final String DATA_RECORD_AUDIO = "recordAudio";
+    public static final String DATA_SMS_SEND = "SmsSend";
+    public static final String DATA_PHONE_CALL = "phoneCall";
+    public static final String DATA_ANDROID_ID = "android_id";
+    public static final String DATA_ICC_ACCESS = "iccAccess";
+    public static final String DATA_WIFI_INFO = "wifiInfo";
+    public static final String DATA_IP_TABLES = "iptables";
+    public static final String DATA_SWITCH_CONNECTIVITY = "switchconnectivity";
+    public static final String DATA_SEND_MMS = "sendMms";
+    public static final String DATA_SWITCH_WIFI_STATE = "switchWifiState";
+    
+    // Database entry ID
+    private final Integer _id;
+    
+    // Application identifiers
+    private String packageName;
+    private int uid;
+    
+    //
+    // Privacy settings
+    //
+    
+    private byte deviceIdSetting;
+    private String deviceId;
+    
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting; 
+    private String line1Number;
+    
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+    
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+    
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+    
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+    
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    private byte bookmarksSetting; // browser bookmarks and history
+    
+    private byte systemLogsSetting;
+    
+    private byte notificationSetting;
+    
+    private byte intentBootCompletedSetting;
+//    private byte externalStorageSetting;
+    private byte cameraSetting;
+    private byte recordAudioSetting;
+    private byte smsSendSetting;
+    private byte phoneCallSetting;
+
+    private byte ipTableProtectSetting;
+    private byte iccAccessSetting;
+    private byte addOnManagementSetting;
+    
+    private byte androidIdSetting;
+    private String androidID;
+    
+    private byte wifiInfoSetting;
+    
+    private byte switchConnectivitySetting;
+    
+    private byte sendMmsSetting;
+    
+    private byte forceOnlineState; //used to fake online state
+    
+    private byte switchWifiStateSetting;
+   
+
+	private int[] allowedContacts;
+	
+	/**
+	 * Constructor to set all Values REAL
+	 * @param _id id in database
+	 * @param packageName	packagename of the app
+	 * @param uid uid of application
+	 * {@hide}
+	 */
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+//        this.externalStorageSetting = REAL;
+        this.cameraSetting = REAL; 
+        this.recordAudioSetting = REAL;
+        this.allowedContacts = null;
+        this.smsSendSetting = REAL;
+        this.phoneCallSetting = REAL;
+        this.ipTableProtectSetting = REAL;
+        this.iccAccessSetting = REAL;
+        this.addOnManagementSetting = EMPTY;
+        this.androidIdSetting = REAL;
+        this.androidID = null;
+        this.wifiInfoSetting = REAL;
+        this.switchConnectivitySetting = REAL;
+        this.sendMmsSetting = REAL;
+        this.forceOnlineState = EMPTY;
+        this.switchWifiStateSetting = REAL;
+    }
+    
+    /**
+     * Constructor for two possibilities:<br>
+     * 1. pass allEmpty = true for set all values to empty
+     * 2. pass allEmpty = false for set all possible values to RANDOM 
+     * @param _id id in database
+     * @param packageName packagename of application
+     * @param uid the uid of application
+     * @param allEmpty see description above
+     * {@hide}
+     */
+    public PrivacySettings(Integer _id, String packageName, int uid, boolean allEmpty) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        if(allEmpty){
+        	this.deviceIdSetting = EMPTY;
+	        this.deviceId = null;
+	        this.line1NumberSetting = EMPTY;
+	        this.line1Number = null;
+	        this.locationGpsSetting = EMPTY;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = EMPTY;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = EMPTY;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = EMPTY;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = EMPTY;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        } else {
+        	this.deviceIdSetting = RANDOM;
+	        this.deviceId = null;
+	        this.line1NumberSetting = RANDOM;
+	        this.line1Number = null;
+	        this.locationGpsSetting = RANDOM;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = RANDOM;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = RANDOM;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = RANDOM;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = RANDOM;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        }
+    }
+    
+    
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat, 
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting, 
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting, 
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting, 
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts, byte smsSendSetting, byte phoneCallSetting, byte ipTableProtectSetting,
+            byte iccAccessSetting, byte addOnManagementSetting, byte androidIdSetting, String androidID, byte wifiInfoSetting, byte switchConnectivitySetting, byte sendMmsSetting,
+            byte forceOnlineState, byte switchWifiStateSetting) {
+        this._id = id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+//        this.externalStorageSetting = externalStorageSetting;
+        this.cameraSetting = cameraSetting;
+        this.recordAudioSetting = recordAudioSetting;
+        this.allowedContacts = allowedContacts;
+        this.smsSendSetting = smsSendSetting;
+        this.phoneCallSetting = phoneCallSetting;
+        this.ipTableProtectSetting = ipTableProtectSetting;
+        this.iccAccessSetting = iccAccessSetting;
+        this.addOnManagementSetting = addOnManagementSetting;
+        this.androidIdSetting = androidIdSetting;
+        this.androidID = androidID;
+        this.wifiInfoSetting = wifiInfoSetting;
+        this.switchConnectivitySetting = switchConnectivitySetting;
+        this.sendMmsSetting = sendMmsSetting;
+        this.forceOnlineState = forceOnlineState;
+        this.switchWifiStateSetting = switchWifiStateSetting;
+    }
+    
+    public byte getSwitchWifiStateSetting() {
+		return switchWifiStateSetting;
+	}
+
+	public void setSwitchWifiStateSetting(byte switchWifiStateSetting) {
+		this.switchWifiStateSetting = switchWifiStateSetting;
+	}
+    
+    public byte getForceOnlineState() {
+		return forceOnlineState;
+	}
+
+	public void setForceOnlineState(byte forceOnlineState) {
+		this.forceOnlineState = forceOnlineState;
+	}
+
+	public byte getSendMmsSetting() {
+		return sendMmsSetting;
+	}
+
+	public void setSendMmsSetting(byte sendMmsSetting) {
+		this.sendMmsSetting = sendMmsSetting;
+	}
+
+	public byte getSwitchConnectivitySetting() {
+		return switchConnectivitySetting;
+	}
+
+	public void setSwitchConnectivitySetting(byte switchConnectivitySetting) {
+		this.switchConnectivitySetting = switchConnectivitySetting;
+	}
+    
+    public byte getAndroidIdSetting() {
+		return androidIdSetting;
+	}
+
+	public void setAndroidIdSetting(byte androidIdSetting) {
+		this.androidIdSetting = androidIdSetting;
+	}
+	
+	/**
+	 * @return random ID, constant fake id or null
+	 */
+	public String getAndroidID() {
+		if(androidIdSetting == EMPTY) return "q4a5w896ay21dr46"; //we can not pull out empty android id, because we get bootlops then
+		if(androidIdSetting == RANDOM) {
+			Random value = new Random();
+			StringBuilder localBuilder = new StringBuilder();
+			for(int i = 0; i < ID_PATTERN.length; i++)
+				localBuilder.append(ID_PATTERN[value.nextInt(ID_PATTERN.length-1)]);
+			return localBuilder.toString();
+		}
+		return androidID;
+	}
+	
+	public byte getWifiInfoSetting() {
+		return wifiInfoSetting;
+	}
+
+	public void setWifiInfoSetting(byte wifiInfoSetting) {
+		this.wifiInfoSetting = wifiInfoSetting;
+	}
+
+	public void setAndroidID(String androidID) {
+		this.androidID = androidID;
+	}
+    
+    public byte getIpTableProtectSetting() {
+		return ipTableProtectSetting;
+	}
+
+	public void setIpTableProtectSetting(byte ipTableProtectSetting) {
+		this.ipTableProtectSetting = ipTableProtectSetting;
+	}
+
+	public byte getIccAccessSetting() {
+		return iccAccessSetting;
+	}
+
+	public void setIccAccessSetting(byte iccAccessSetting) {
+		this.iccAccessSetting = iccAccessSetting;
+	}
+
+	public byte getAddOnManagementSetting() {
+		return addOnManagementSetting;
+	}
+
+	public void setAddOnManagementSetting(byte addOnManagementSetting) {
+		this.addOnManagementSetting = addOnManagementSetting;
+	}
+    public byte getSmsSendSetting(){
+	return smsSendSetting;
+    }
+
+    public void setSmsSendSetting(byte smsSendSetting){
+	this.smsSendSetting = smsSendSetting;
+    }
+
+    public byte getPhoneCallSetting(){
+	return phoneCallSetting;
+    }
+
+    public void setPhoneCallSetting(byte phoneCallSetting){
+	this.phoneCallSetting = phoneCallSetting;
+    }
+
+    public byte getRecordAudioSetting(){
+	return recordAudioSetting;
+    }
+
+    public void setRecordAudioSetting(byte recordAudioSetting){
+	this.recordAudioSetting = recordAudioSetting;
+    }
+
+    public byte getCameraSetting(){
+	return cameraSetting;
+    }
+
+    public void setCameraSetting(byte cameraSetting){
+	this.cameraSetting = cameraSetting;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+    
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+            //return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 13)
+            	return rndId.substring(0, 13);
+	    else{
+		for(int i = rndId.length(); i <= 14; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 13);
+	    }
+            //return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+    
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";        
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();  
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+    
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+    
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+    
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + ", phoneCallSetting=" + phoneCallSetting 
+                + ", smsSendSetting=" + smsSendSetting + ", recordAudioSetting=" + recordAudioSetting + ", cameraSetting=" 
+                + cameraSetting + ", ipTableProtectSetting=" + ipTableProtectSetting + ", iccAccessSetting=" + iccAccessSetting 
+                + ", addOnManagementSetting=" + addOnManagementSetting + ", android ID=" + androidID + ", androidIdSetting="
+                + androidIdSetting + ", wifiInfoSetting=" + wifiInfoSetting + ", switchConnectivitySetting=" + switchConnectivitySetting 
+                + ", sendMmsSetting=" + sendMmsSetting + ", forceOnlineState=" + forceOnlineState + ", switchWifiStateSetting=" 
+                + switchWifiStateSetting + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+    
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+    
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+//        this.externalStorageSetting = in.readByte();
+        this.cameraSetting = in.readByte();
+        this.recordAudioSetting = in.readByte();
+//        int[] buffer = in.createIntArray();
+//        if (buffer != null && buffer.length > 0) {
+//            in.readIntArray(buffer);
+//            int count = 0;
+//            for (int i = 0; i < buffer.length; i++) if (buffer[i] != 0) count++; else break;
+//            this.allowedContacts = new int[count];
+//            System.arraycopy(buffer, 0, allowedContacts, 0, count);
+//        } // else it will be null
+        
+        this.allowedContacts = in.createIntArray();
+        this.smsSendSetting = in.readByte();
+        this.phoneCallSetting = in.readByte();
+        this.ipTableProtectSetting = in.readByte();
+        this.iccAccessSetting = in.readByte();
+        this.addOnManagementSetting = in.readByte();
+        this.androidIdSetting = in.readByte();
+        this.androidID = in.readString();
+        this.wifiInfoSetting = in.readByte();
+        this.switchConnectivitySetting = in.readByte();
+        this.sendMmsSetting = in.readByte();
+        this.forceOnlineState = in.readByte();
+        this.switchWifiStateSetting = in.readByte();
+        
+    }
+    
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+//        dest.writeByte(externalStorageSetting);
+        dest.writeByte(cameraSetting);
+        dest.writeByte(recordAudioSetting);
+        dest.writeIntArray(allowedContacts);
+        dest.writeByte(smsSendSetting);
+        dest.writeByte(phoneCallSetting);
+        dest.writeByte(ipTableProtectSetting);
+        dest.writeByte(iccAccessSetting);
+        dest.writeByte(addOnManagementSetting);
+        dest.writeByte(androidIdSetting);
+        dest.writeString(androidID);
+        dest.writeByte(wifiInfoSetting);
+        dest.writeByte(switchConnectivitySetting);
+        dest.writeByte(sendMmsSetting);
+        dest.writeByte(forceOnlineState);
+        dest.writeByte(switchWifiStateSetting);
+    }
+    
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+    
+	
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManager.java b/privacy/java/android/privacy/PrivacySettingsManager.java
new file mode 100644
index 0000000..d917690
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManager.java
@@ -0,0 +1,215 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public final class PrivacySettingsManager {
+
+    private static final String TAG = "PrivacySettingsManager";
+    
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    public static final String ACTION_PRIVACY_NOTIFICATION_ADDON = "com.privacy.pdroid.PRIVACY_NOTIFICATION_ADDON";
+    
+    private IPrivacySettingsManager service;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+//        Log.d(TAG, "PrivacySettingsManager - initializing for package: " + context.getPackageName() + 
+//                " UID:" + Binder.getCallingUid());
+        this.service = service;
+    }
+
+    @Deprecated
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+        try {
+            if (service != null) {
+                return service.getSettings(packageName);
+            } else {
+                Log.e(TAG, "getSettings - PrivacySettingsManagerService is null");
+                return null;
+            }
+        } catch (RemoteException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        try {
+//            Log.d(TAG, "saveSettings - " + settings);
+            if (service != null) {            
+                return service.saveSettings(settings);
+            } else {
+                Log.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in saveSettings: ", e);
+            return false;
+        }
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        try {
+            if (service != null) {
+                return service.deleteSettings(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in deleteSettings: ", e);
+            return false;
+        }
+    }
+    
+    @Deprecated
+    public boolean deleteSettings(String packageName, int uid) {
+        return deleteSettings(packageName);
+    }
+    
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    public boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+    
+    @Deprecated
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output);
+    }
+    
+    @Deprecated
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output);
+    }
+
+    public void notification(String packageName, byte accessMode, String dataType, String output) {
+          try {
+              if (service != null) {
+                  service.notification(packageName, accessMode, dataType, output);
+              } else {
+                  Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+              }            
+          } catch (RemoteException e) {
+              Log.e(TAG, "RemoteException in notification: ", e);
+          }
+  }
+    
+    public void registerObservers() {
+        try {
+            if (service != null) {
+                service.registerObservers();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in registerObservers: ", e);
+        }
+    }
+    
+    public void addObserver(String packageName) {
+        try {
+            if (service != null) {
+                service.addObserver(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in addObserver: ", e);
+        }
+    }
+    
+    public boolean purgeSettings() {
+        try {
+            if (service != null) {
+                return service.purgeSettings();
+            } else {
+				Log.e(TAG, "purgeSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in purgeSettings: ", e);
+        }
+        return false;
+    }
+    
+    public double getVersion() {
+        try {
+            if (service != null) {
+                return service.getVersion();
+            } else {
+                Log.e(TAG, "getVersion - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in getVersion: ", e);
+        }
+        return 0;
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setEnabled(enable);
+            } else {
+                Log.e(TAG, "setEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+                Log.e(TAG, "setNotificationsEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setNotificationsEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public void setBootCompleted() {
+        try {
+            if (service != null) {
+                service.setBootCompleted();
+            } else {
+                Log.e(TAG, "setBootCompleted - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setBootCompleted: ", e);
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManagerService.java b/privacy/java/android/privacy/PrivacySettingsManagerService.java
new file mode 100644
index 0000000..9b6c97b
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManagerService.java
@@ -0,0 +1,236 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * 
+ * @author Svyatoslav Hresyk TODO: add selective contact access management API
+ * 
+ *         {@hide}
+ */
+public final class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+
+    private static final String TAG = "PrivacySettingsManagerService";
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+    private static final String READ_PRIVACY_SETTINGS = "android.privacy.READ_PRIVACY_SETTINGS";
+
+    private PrivacyPersistenceAdapter persistenceAdapter;
+    
+    private Context context;
+
+    public static PrivacyFileObserver obs;
+
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+
+    private static final double VERSION = 1.51;
+
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        Log.i(TAG,
+                "PrivacySettingsManagerService - initializing for package: "
+                        + context.getPackageName() + " UID: " + Binder.getCallingUid());
+        this.context = context;
+
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(
+                PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(
+                PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(
+                PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+
+    public PrivacySettings getSettings(String packageName) {
+        // Log.d(TAG, "getSettings - " + packageName);
+        if (enabled || context.getPackageName().equals("com.privacy.pdroid")
+                || context.getPackageName().equals("com.privacy.pdroid.Addon")
+                || context.getPackageName().equals("com.android.privacy.pdroid.extension"))
+            // we have to add our addon package here, to get real settings
+            return persistenceAdapter.getSettings(packageName);
+        else
+            return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) throws RemoteException {
+        Log.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid()
+                + ") has sufficient permissions");
+        // Why are we letting the system delete package settings??
+        if (Binder.getCallingUid() != 1000) {
+            checkCallerCanWriteOrThrow();
+        }
+        
+        Log.d(TAG, "saveSettings - " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true)
+            obs.addObserver(settings.getPackageName());
+        return result;
+    }
+
+    public boolean deleteSettings(String packageName) throws RemoteException {
+        // Why are we letting the system delete package settings??
+        if (Binder.getCallingUid() != 1000) {
+            checkCallerCanWriteOrThrow();
+        }
+
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+
+    public double getVersion() {
+        return VERSION;
+    }
+
+    public void notification(final String packageName, final byte accessMode,
+            final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled) {
+            Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent);
+        }
+    }
+
+    public void registerObservers() throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+
+    public void addObserver(String packageName) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        obs.addObserver(packageName);
+    }
+
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+
+    public boolean setNotificationsEnabled(boolean enable) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE
+                : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED,
+                value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Enables or disables PDroid protection. If 'enabled' = true, PDroid will
+     * return valid settings. Otherwise it will return 'null', which allows all.
+     * Setting to 'enabled' has immediate effects; setting to 'disabled' has no effect until next reboot.
+     * @param newIsEnabled 
+     * @return new 'enabled' state.
+     */
+    public boolean setEnabled(boolean newIsEnabled) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        String value = newIsEnabled ? PrivacyPersistenceAdapter.VALUE_TRUE
+                : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+        /**
+     * Check the caller of the service has privileges to write to it
+	 * Throw an exception if not. 
+	 */
+	private void checkCallerCanWriteOrThrow() throws RemoteException {
+		context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS,
+				"Requires WRITE_PRIVACY_SETTINGS");
+		//for future:
+		// if not allowed then throw
+		//			throw new SecurityException("Attempted to write without sufficient priviliges");
+
+	}
+	
+	/**
+	 * Check that the caller of the service has privileges to write to it.
+	 * @return true if caller can write, false otherwise.
+	 */
+	private boolean checkCallerCanWriteSettings() throws RemoteException {
+		try {
+			checkCallerCanWriteOrThrow();
+			return true;
+		} catch (SecurityException e) {
+			return false;
+		}
+	}
+
+	/**
+	 * Check the caller of the service has privileges to read from it
+	 * Throw an exception if not. 
+	 */
+	private void checkCallerCanReadOrThrow() {
+		if (Binder.getCallingUid() == 1000) {
+			return;
+		}
+		context.enforceCallingPermission(READ_PRIVACY_SETTINGS,
+				"Requires READ_PRIVACY_SETTINGS");
+		//for future:
+		// if not allowed then throw
+		//			throw new SecurityException("Attempted to read without sufficient priviliges");
+
+	}
+	
+	/**
+	 * Check that the caller of the service has privileges to read from it.
+	 * @return true if caller can read, false otherwise.
+	 */
+	private boolean checkCallerCanReadSettings() {
+		try {
+			checkCallerCanReadOrThrow();
+			return true;
+		} catch (SecurityException e) {
+			return false;
+		}
+	}
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
new file mode 100644
index 0000000..8a487b7
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
@@ -0,0 +1,297 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    
+    private static final String TAG = "PrivacyAccountManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));  
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+    
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts(); 
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccounts - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccountsByType - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+    
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);        
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "hasFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);       
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "getAccountsByTypeAndFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * USE_CREDENTIALS
+     */
+    
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);    
+        String output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "blockingGetAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " 
+//                + (output == null ? "[null]" : output));
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthTokenByFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        
+        private V result;
+        
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+        
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
new file mode 100644
index 0000000..0ab3bd4
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
@@ -0,0 +1,296 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.PrivacySettingsManagerService;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    
+    private static final String TAG = "PrivacyActivityManagerService";
+    
+    private static final String SMS_RECEIVED_ACTION_INTENT = "android.provider.Telephony.SMS_RECEIVED";
+    private static final String WAP_PUSH_RECEIVED_INTENT = "android.provider.Telephony.WAP_PUSH_RECEIVED";
+    private static final String DATA_SMS_RECEIVED_INTENT = "android.intent.action.DATA_SMS_RECEIVED";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+    
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+    
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+    
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+    
+    private static long tmpPackageAddedHash = 0;
+    
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to 
+     * privacy permissions
+     * @param packageName may not be null
+     * @param context if you use JellyBean, just pass NULL because all is splittet up to BroadcastQueue.java!!
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null && context != null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+	if (pSetMan == null && context == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy"))); //we can pass null here
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpOut = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+            
+            pSet = pSetMan.getSettings(packageName, uid);
+            
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpIn = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming SMS
+        } else if (action.equals(SMS_RECEIVED_ACTION_INTENT)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+//            Log.d(TAG, "package: " + packageName + " uid: " + uid);
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpSmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpSmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    
+//                    Log.d(TAG, "permission denied, replaced pdu; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                        "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpSmsHash);
+                tmpSms = null;
+            }            
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming MMS
+        } else if (action.equals(WAP_PUSH_RECEIVED_INTENT) ||
+                action.equals(DATA_SMS_RECEIVED_INTENT)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpMmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpMmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpMmsHash);
+                tmpMms = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+            
+            pSet = pSetMan.getSettings(packageName);
+            
+            if (pSet != null && pSet.getIntentBootCompletedSetting() != PrivacySettings.REAL) {
+                //no notification since all applications will receive this -> spam
+                intent.setAction("catchBootComplete");
+		//Log.i(TAG,"package: " + packageName + " blocked INTENT_BOOT_COMPLETE");
+                //intent.setPackage("com.android.privacy.pdroid.extension");
+                pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            } else {
+                intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+		//Log.i(TAG,"package: " + packageName + " allowed INTENT_BOOT_COMPLETE");
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            }
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+//            Log.d(TAG, "enforcePrivacyPermission - ACTION_PACKAGE_ADDED; receivers: " + receivers);
+            
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+                
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+//                Log.d(TAG, "enforcePrivacyPermission - installed package " + addedPackageName + " " + addedUid);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) { // update the UID
+//                    Log.i(TAG, "installed package UID (" + addedUid + ") doesn't match privacy settings UID (" + pSet.getUid() + "); updating...");
+                    pSet.setUid(addedUid);
+                    /*boolean updateSuccess = */pSetMan.saveSettings(pSet);
+//                    if (!updateSuccess) Log.w(TAG, "could not update privacy settings UID; purge needed");
+                }
+            }
+        }
+    }
+    
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java b/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
new file mode 100644
index 0000000..96b7357
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
@@ -0,0 +1,206 @@
+package android.privacy.surrogate;
+
+import java.net.InetAddress;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.IConnectivityManager;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyConnectivityManager extends ConnectivityManager{
+
+	private static final String P_TAG = "PrivacyConnectivityManager";
+	
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	public PrivacyConnectivityManager(IConnectivityManager service, Context context) {
+		super(service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"now in constructor for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public boolean getMobileDataEnabled() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		}
+//		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+//			return false;
+//		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return super.getMobileDataEnabled();
+		}
+			
+	}
+	
+	@Override
+	public void setMobileDataEnabled(boolean enabled) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getSwitchConnectivitySetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null); 
+			//do nothing
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			super.setMobileDataEnabled(enabled);
+		}
+	}
+	
+	@Override
+	public NetworkInfo[] getAllNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output[] =  {new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED")};
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output[0].setIsAvailable(true); 
+			output[0].setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getAllNetworkInfo();
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getNetworkInfo(int networkType) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getNetworkInfo(networkType);
+		}
+			
+	}
+	
+	/**
+	 * {@hide}
+	 */
+	@Override
+	public NetworkInfo getActiveNetworkInfoForUid(int uid) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveNetworkInfoForUid(uid);
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getActiveNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveNetworkInfo();
+		}
+			
+	}
+	
+	@Override
+	public LinkProperties getLinkProperties(int networkType) { //method to prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getLinkProperties(networkType);
+		}
+	}
+	
+	public LinkProperties getActiveLinkProperties() { //also for prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveLinkProperties();
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHost(int networkType, int hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHost(networkType, hostAddress);
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHostAddress(networkType, hostAddress);
+		}
+	}
+	
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
new file mode 100644
index 0000000..8fdd1f6
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
@@ -0,0 +1,251 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.IContentProvider;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk 
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+
+    private static final String TAG = "PrivacyContentResolver";
+
+    private static final String SMS_CONTENT_URI_AUTHORITY = "sms";
+    private static final String MMS_CONTENT_URI_AUTHORITY = "mms";
+    private static final String MMS_SMS_CONTENT_URI_AUTHORITY = "mms-sms";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+//    public static Cursor enforcePrivacyPermission(Uri uri, Context context, Cursor realCursor) {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM && 
+                                uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+//                            Log.d(TAG, "enforcePrivacyPermission - URI: " + uri.toString() + " " + uri.getAuthority() + " " + uri.getEncodedAuthority() + " " + uri.getEncodedFragment() + " " + uri.getEncodedPath() + " " + uri.getEncodedQuery() + " " + uri.getEncodedSchemeSpecificPart() + " " + uri.getEncodedUserInfo() + " " + uri.getFragment() + " " + uri.getPath());
+//                            Log.d(TAG, "enforcePrivacyPermission - projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+//                            Log.d(TAG, "enforcePrivacyPermission - cursor entries: " + output.getCount());
+                            
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                                
+//                                if (!idFound) { // add ID to projection
+//                                    String[] newProjection = new String[projection.length + 1];
+//                                    System.arraycopy(projection, 0, newProjection, 0, projection.length);
+//                                    newProjection[projection.length] = ContactsContract.Contacts._ID;
+//                                    projection = newProjection;
+//                                }
+                            }
+                            
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+//                            Log.d(TAG, "enforcePrivacyPermission - new projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            
+                            // re-query
+//                            output = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+//                            Log.d(TAG, "enforcePrivacyPermission - new cursor entries: " + output.getCount());
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else { // REAL
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    }
+                    
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                    
+                } else if (auth.equals(MMS_CONTENT_URI_AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(SMS_CONTENT_URI_AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MMS_SMS_CONTENT_URI_AUTHORITY) || 
+                        auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) { 
+                    
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null && (pSet.getMmsSetting() == PrivacySettings.EMPTY || 
+                            pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                    
+                }
+            }
+//            Log.d(TAG, "query - " + packageName + " (" + uid + ") auth: " + auth + " output: " + output_label);
+            return output;
+        }
+        return realCursor;
+    }
+    
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+    /**
+     * This method is especially for faking android_id if google wants to read it in their privacy database
+     * @author CollegeDev
+     * @param uri
+     * @param projection
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor, boolean google_access) throws RemoteException {
+	if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null && auth.equals("com.google.android.gsf.gservices")) {
+		
+		if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL){
+			int actual_pos = realCursor.getPosition();
+			int forbidden_position = -1;
+			try{
+				for(int i=0;i<realCursor.getCount();i++){
+					realCursor.moveToNext();
+					if(realCursor.getString(0).equals("android_id")){
+						forbidden_position = realCursor.getPosition();
+						break;
+					}
+				}
+			} catch (Exception e){
+				Log.e(TAG,"something went wrong while getting blocked permission for android id");
+			} finally{
+				realCursor.moveToPosition(actual_pos);
+				if(forbidden_position == -1) {Log.i(TAG,"now we return real cursor, because forbidden_pos is -1"); return output;} //give realcursor, because there is no android_id to block
+			}
+			Log.i(TAG,"now blocking google access to android id and give fake cursor. forbidden_position: " + forbidden_position);
+			output_label = "[fake]";
+			output = new PrivacyCursor(realCursor,forbidden_position);	
+			pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+		} else {
+			Log.i(TAG,"google is allowed to get real cursor");
+			pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+		}
+	    }
+	    return output;
+	}
+	return realCursor;   
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyCursor.java b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
new file mode 100644
index 0000000..dc46610
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
@@ -0,0 +1,496 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Random;
+
+import java.math.BigInteger;
+import java.util.Map;
+
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver} 
+ * when access should be blocked without crashing the calling application (for this purpose none 
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    
+    private Cursor realCursor;
+    
+    private int[] allowedIds;
+
+    private int blockedColumnAndroidID; 
+
+    private static final String[] mask = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};
+
+    private boolean googleCursor;
+    
+    private int[] allowedIdMapping;
+    
+    private final static String TAG = "PrivacyCursor";
+    
+    public PrivacyCursor() {
+    }
+    
+    /**
+     * 
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+    /*
+     * This constructor is only for android_id	 
+     * @param blockedColumnAndroidID pass -11 if should block all, or the columnIndex where android_id is!
+     */
+    public PrivacyCursor(Cursor realCursor, int blockedColumnAndroidID){
+	if(blockedColumnAndroidID == -11)
+		this.realCursor = null;
+	else
+		this.realCursor = realCursor;
+	this.blockedColumnAndroidID = blockedColumnAndroidID;
+	this.googleCursor = true;
+	Log.i(TAG,"constructor is ready for google cursor! forbidden_position: " + blockedColumnAndroidID);
+    }
+     
+    /**
+     * just create fakeID
+     * @return fake ID or null if something went wrong
+     */
+    private String getFakeID(){
+	try{
+		Random rand = new Random();
+		String output = "";
+		for(int i=0; i < 16;i++){
+			output += mask[rand.nextInt(15)];
+		}
+		return output;
+	} catch (Exception e){
+		Log.e(TAG,"something went wrong with creating fake ID");
+		return null;
+	}
+    }
+
+    @Override
+    public void close() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            Log.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+	else if (realCursor != null)
+	    return realCursor.getCount();
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+//            Log.d(TAG, "getInt - columnIndex: " + columnIndex + " name: " + realCursor.getColumnName(columnIndex) + " result: " + result);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            int result = getMappedPos(realCursor.getPosition());
+            Log.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+	else if (realCursor != null)
+	    return realCursor.getPosition();
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+	if(googleCursor && (columnIndex == 1) && (realCursor.getPosition() == blockedColumnAndroidID)){	
+		Log.i(TAG,"google tries to get android_id with getString()");
+		String id = getFakeID();
+		if(id != null){
+			try{
+				BigInteger value = new BigInteger(id,16);
+				String fakeValue = String.valueOf(value);
+				Log.i(TAG,"returned : " + fakeValue + "(String) as fake android id");
+				return fakeValue;
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.i(TAG,"returned \"\" as android_id");
+				return "";
+			}
+		}
+		else{Log.i(TAG,"returned \"\" as android_id"); return "";}
+	}
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            Log.d(TAG, "isFirst");
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+	else if(realCursor != null)
+	    return realCursor.isFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            Log.d(TAG, "isLast");
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+	else if (realCursor != null)
+	    return realCursor.isLast();
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            Log.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+//                Log.d(TAG, "move - position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null) //here we go with our google cursor
+		realCursor.move(offset);
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]); 
+//            Log.d(TAG, "moveToFirst - position: " + allowedIdMapping[0] + " result: " + result);
+            return result;
+        }
+	else if (realCursor != null)
+		return realCursor.moveToFirst();
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+//            Log.d(TAG, "moveToLast - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToLast();
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+//            Log.d(TAG, "moveToNext - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToNext();
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+//                Log.d(TAG, "moveToPosition - real position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPosition(position);
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+//            Log.d(TAG, "moveToPrevious - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPrevious();
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerContentObserver(observer);        
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);        
+    }
+
+    @Override
+    public boolean requery() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.respond(extras);        
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);        
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);        
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex); 
+//        Log.d(TAG, "getContactId - colIndex: " + colIndex + " id: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+//        Log.d(TAG, "isAllowed - id: " + id + " result: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+    
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+	
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
new file mode 100644
index 0000000..166f7ce
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
@@ -0,0 +1,532 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+
+    private static final String TAG = "PrivacyLocationManager";
+    
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private Object lock = new Object();
+    
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+//        Log.d(TAG, "addNmeaListener - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: [real value]");
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+        
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        Location output = null;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) && 
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        
+//        Log.d(TAG, "getLastKnownLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        LocationProvider output = null;
+        
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+            
+//        Log.d(TAG, "getProvider - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + 
+//                (output != null ? "[real value]" : "[null]"));
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else { // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        
+//        Log.d(TAG, "isProviderEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") provider: " 
+//                + provider + "output: " + output);
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+    
+    /**
+     * Monitoring purposes only
+     */
+//    @Override
+//    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
+//        Log.d(TAG, "sendExtraCommand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        return super.sendExtraCommand(provider, command, extras);
+//    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) { // custom listener should only return a value after this method has returned
+
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+            
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else { // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            
+//            Log.d(TAG, "requestLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                    ") output: " + (output == true ? "[custom location]" : "[real value]"));
+            return output;
+        }
+    }
+    
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to 
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+            // treat providers with high accuracy as GPS providers
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE || 
+                criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else { // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+    
+    private class PrivacyLocationUpdater extends Thread {
+        
+        private String provider;
+        
+        private LocationListener listener;
+        
+        private PendingIntent intent;
+        
+        private double latitude;
+        
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
new file mode 100644
index 0000000..5beefe4
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
@@ -0,0 +1,520 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Random;
+
+import android.telephony.CellInfo;
+
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+
+    private static final String TAG = "PrivacyTelephonyManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException: 
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+    
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+//        Log.d(TAG, "getDeviceId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getLine1Number - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+        
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+        
+//        Log.d(TAG, "getNeighboringCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);
+        return output;
+    }
+    
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+//        Log.d(TAG, "getNetworkCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+//        Log.d(TAG, "getNetworkOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+//        Log.d(TAG, "getNetworkOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return null;
+        }        
+    }
+    
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+//        Log.d(TAG, "getSimCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+//        Log.d(TAG, "getSimOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+//        Log.d(TAG, "getSimOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */    
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return null;
+        }                
+    }
+    
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getSimSerialNumber(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        } else {
+            output = super.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        }
+//        Log.d(TAG, "getSimSerialNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+	Log.i(TAG, "getSubscriberId() - " + context.getPackageName());
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+//        Log.d(TAG, "getSubscriberId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    /**
+     * For monitoring purposes only
+     */    
+//    @Override
+//    public void enableLocationUpdates() {
+////        Log.d(TAG, "enableLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        super.enableLocationUpdates();
+//    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+//        Log.d(TAG, "listen - package:" + context.getPackageName() + " uid:" + Binder.getCallingUid() + " events: " + events);
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) || ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+	    //first check if context exists
+	    String pkgForDebug = context != null ? context.getPackageName() : null;
+	    if(pkgForDebug != null){
+            	listener.setPackageName(pkgForDebug); //we only have to set it if context != null, because if context == null will cause the listener gives no update to app
+		listener.setContext(context);
+            }
+            listener.setUid(Binder.getCallingUid());
+            super.listen(listener, events);
+//            Log.d(TAG, "listen for cell location or call state - " + context.getPackageName() + " (" + 
+//                    Binder.getCallingUid() + ") output: custom listener");
+        } else {
+            super.listen(listener, events);
+        }
+    }
+    //NEW PRIVACY------------------------------------------------------------------------------------------------------------------------------------------
+ 
+   /**
+     * Returns the current location of the device.
+     * Return null if current location is not available.
+     * That method is new -> fix it!
+     * @author CollegeDev
+     */
+    @Override
+    public CellLocation getCellLocation() {
+        try {
+	    String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            if (pSet != null && ((pSet.getLocationNetworkSetting() != PrivacySettings.REAL) || (pSet.getLocationGpsSetting() != PrivacySettings.REAL))) {
+		pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+		return null;
+	    } else {
+		pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+		CellLocation cl = super.getCellLocation();
+		return cl;
+	    }
+        } catch(Exception e) {
+		return null;
+	}
+    }
+    
+   /**
+     * Returns the software version number for the device, for example,
+     * the IMEI/SV for GSM phones. Can control with deviceIdSetting
+     *
+     */
+    @Override
+    public String getDeviceSoftwareVersion() {
+        try {
+	    String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	    String output = "";
+	    if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            	output = pSet.getDeviceId(); // can be empty, custom or random
+            	pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+       	    } else {
+            	output = super.getDeviceSoftwareVersion();
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            }
+            return output;
+        } catch (Exception e){
+		return null;
+	}
+    }
+
+    /**
+     * 
+     * @hide
+     */
+    @Override
+    public String getCompleteVoiceMailNumber() {
+        try {
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	    String output = "";
+	    if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            	output = pSet.getLine1Number(); // can be empty, custom or random
+            	pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            } else {
+            	output = super.getCompleteVoiceMailNumber();
+           	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+       	    }
+            return output;
+        } catch (Exception e){
+		return null;
+	}
+    }
+    //all types for better overview, based on ics 4.0.4
+    private static final int PHONE_TYPES[] = {PHONE_TYPE_NONE, PHONE_TYPE_GSM, PHONE_TYPE_CDMA, PHONE_TYPE_SIP};
+    private static final int NETWORK_TYPES[] = {NETWORK_TYPE_UNKNOWN, NETWORK_TYPE_GPRS, NETWORK_TYPE_EDGE,
+						NETWORK_TYPE_UMTS, NETWORK_TYPE_CDMA, NETWORK_TYPE_EVDO_0,
+						NETWORK_TYPE_EVDO_A, NETWORK_TYPE_1xRTT, NETWORK_TYPE_HSDPA,
+						NETWORK_TYPE_HSUPA, NETWORK_TYPE_HSPA, NETWORK_TYPE_IDEN,
+						NETWORK_TYPE_EVDO_B, NETWORK_TYPE_LTE, NETWORK_TYPE_EHRPD,
+						NETWORK_TYPE_HSPAP};
+
+    /**
+     * Returns a constant indicating the device phone type.  If user block network info, it returns random generated type of phone.
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     * @see #PHONE_TYPE_SIP
+     */
+    @Override
+    public int getPhoneType() {
+	String output = getNetworkInfo();
+	//no random support until now in pdroid, change addonApp to support it?
+	//Random x = new Random();
+	int type = PHONE_TYPES[/*x.nextInt(PHONE_TYPES.length-1)*/0];
+	if(output == null) type = super.getPhoneType();
+        return type;
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently in use on the device for data transmission.(If user block network info, it returns random generated type of network.)
+     * @return the network type
+     *
+     * @see #NETWORK_TYPE_UNKNOWN
+     * @see #NETWORK_TYPE_GPRS
+     * @see #NETWORK_TYPE_EDGE
+     * @see #NETWORK_TYPE_UMTS
+     * @see #NETWORK_TYPE_HSDPA
+     * @see #NETWORK_TYPE_HSUPA
+     * @see #NETWORK_TYPE_HSPA
+     * @see #NETWORK_TYPE_CDMA
+     * @see #NETWORK_TYPE_EVDO_0
+     * @see #NETWORK_TYPE_EVDO_A
+     * @see #NETWORK_TYPE_EVDO_B
+     * @see #NETWORK_TYPE_1xRTT
+     * @see #NETWORK_TYPE_IDEN
+     * @see #NETWORK_TYPE_LTE
+     * @see #NETWORK_TYPE_EHRPD
+     * @see #NETWORK_TYPE_HSPAP
+     */
+    @Override
+    public int getNetworkType() {
+        try{
+            String output = getNetworkInfo();
+	    //no random support until now in pdroid, change addonApp to support it?
+	    //Random x = new Random();
+	    int type = NETWORK_TYPES[/*x.nextInt(NETWORK_TYPES.length-1)*/0];
+            if(output == null) type = super.getNetworkType();
+	    return type;
+
+        } catch(Exception e){
+        	return NETWORK_TYPES[0];
+        }
+    }
+    
+    /**
+     * Will be handled like getLine1Number
+     */
+    @Override
+    public String getLine1AlphaTag(){
+    	return getLine1Number();
+    }
+    
+    /**
+     * 15 character long numbers -> handle same as imsi
+     */
+    public String getMsisdn() {
+	Log.i(TAG, "getMsisdn() - " + context.getPackageName());
+    	return getSubscriberId();
+    }
+    
+    /**
+     * It doesn't matter if we give some shit to it, it will work
+     */
+    public String getVoiceMailAlphaTag() {
+    	return getVoiceMailNumber();
+    }
+    
+    /**
+     * @hide
+     * handles like subscriber id
+     */
+    public String getIsimImpi() {
+	Log.i(TAG, "getIsimImpi - " + context.getPackageName());
+    	return getSubscriberId();
+    }
+    
+    /**
+     * @hide
+     * lets play with this function, handled like NetworkOperatorName
+     */
+    public String getIsimDomain() {
+    	return getNetworkOperatorName();
+    }
+    
+    /**
+     * @hide
+     * lets play with this function, handled like subscriberID
+     */
+    public String[] getIsimImpu() {
+    	String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	Log.i(TAG, "getIsimImpu() - " + context.getPackageName());
+        String output[] = new String[1];
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output[0] = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);            
+        } else {
+            output = super.getIsimImpu();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);            
+        }
+        return output;
+    }
+    /**
+     * @hide
+     * @return
+     */
+    public List<CellInfo> getAllCellInfo() {
+    	PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<CellInfo> output = null;
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+            	output = new ArrayList<CellInfo>();
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<CellInfo>();
+            } else {
+                output = super.getAllCellInfo();
+            }
+        }
+        return output;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java b/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
new file mode 100644
index 0000000..c9977dd
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
@@ -0,0 +1,207 @@
+package android.privacy.surrogate;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.content.Context;
+import android.net.DhcpInfo;
+import android.net.wifi.IWifiManager;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for WifiManager
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyWifiManager extends WifiManager{
+
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final String P_TAG = "PrivacyWifiManager";
+	
+
+	public PrivacyWifiManager(Context context, IWifiManager service){
+		super(context, service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+	}
+	
+	@Override
+	public List<WifiConfiguration> getConfiguredNetworks() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		List<WifiConfiguration> output = new ArrayList<WifiConfiguration>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);   
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConfiguredNetworks();
+		}
+	}
+	
+	@Override
+	public WifiInfo getConnectionInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		//we have to change WifiInfo constructor for faking data -> change WifiInfo in framework!
+		WifiInfo output = new WifiInfo(true);
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConnectionInfo();
+		}
+	}
+	
+	@Override
+	public List<ScanResult> getScanResults() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		List<ScanResult> output = new ArrayList<ScanResult>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getScanResults();
+		}
+	}
+	
+	@Override
+	public int getFrequencyBand() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return -1;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getFrequencyBand();
+		}
+	}
+	
+	@Override
+	public DhcpInfo getDhcpInfo(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return new DhcpInfo();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getDhcpInfo();
+		}
+	}
+	
+	/**
+	 * @hide
+	 * @return
+	 */
+	@Override
+	public WifiConfiguration getWifiApConfiguration(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return new WifiConfiguration();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getWifiApConfiguration();
+		}
+	}
+	
+
+	@Override
+	public String getConfigFile(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return "";
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConfigFile();
+		}
+	}
+	//new
+	@Override
+	public boolean startScan(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.startScan();
+		}
+	}
+	
+	
+	@Override
+	public boolean startScanActive(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.startScanActive();
+		}
+	}
+	
+	@Override
+	public boolean setWifiEnabled(boolean enabled){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getSwitchWifiStateSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null); 
+			return super.setWifiEnabled(enabled);
+		}
+	}
+	
+	@Override
+	public int getWifiState(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return WIFI_STATE_ENABLED;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return WIFI_STATE_UNKNOWN;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return super.getWifiState();
+		}
+	}
+	
+	@Override
+	public boolean isWifiEnabled(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return super.isWifiEnabled();
+		}
+	}
+}
diff --git a/services/java/com/android/server/PrivacyTelephonyRegistry.java b/services/java/com/android/server/PrivacyTelephonyRegistry.java
new file mode 100644
index 0000000..36f2d9e
--- /dev/null
+++ b/services/java/com/android/server/PrivacyTelephonyRegistry.java
@@ -0,0 +1,402 @@
+package com.android.server;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellIdentityGsm;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+import android.util.Log;
+import android.os.Process;
+
+
+public class PrivacyTelephonyRegistry extends TelephonyRegistry{
+
+	private static final String P_TAG = "PrivacyTelephonyRegistry";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final int PERMISSION_CELL_LOCATION = 0;
+	
+	private static final int PERMISSION_CELL_INFO = 1;
+	
+	private static final int PERMISSION_SIGNAL_STRENGTH = 2;
+	
+	private static final int PERMISSION_CALL_STATE = 3;
+	
+	private static final int PERMISSION_SERVICE_STATE = 4;
+	
+	public PrivacyTelephonyRegistry(Context context) {
+		super(context);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			Log.e(P_TAG,"failed to register privacy broadcastreceiver");
+		}
+		Log.i(P_TAG,"constructor ready");
+	}
+	
+	/** This broadCastReceiver receives the privacy intent for blocking phonecalls and faking phonestate */
+	private final BroadcastReceiver privacyReceiver = new BroadcastReceiver()
+    {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if(intent.getAction().equals("android.privacy.BLOCKED_PHONE_CALL")){
+            	Bundle data = new Bundle();
+            	data = intent.getExtras();
+            	String packageName = data.getString("packageName");
+            	if(data.containsKey("packageName")){
+            		Log.i(P_TAG, "got blocked phone call INTENT from package: " + data.getString("packageName"));
+            	} else{
+            		Log.i(P_TAG, "got blocked phone call INTENT without package information");
+            	}
+            	if(packageName == null) return;
+            	if(data.containsKey("phoneState")){
+            		int state = data.getInt("phoneState");
+            		switch(state){
+            			case TelephonyManager.CALL_STATE_IDLE:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_IDLE, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_OFFHOOK:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_OFFHOOK, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_RINGING:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_RINGING, "12345", packageName);
+            				return;
+            			default:
+            				return;
+            		}
+            	}
+            	Log.i(P_TAG,"we forgot to put phoneState in Intent?");
+            }
+        }
+    };
+    
+    /**
+     * This method allows us to fake a call state if application uses phoneStateListener. It will call the onCallStateChanged method with faked state and number
+     * @param state {@link TelephonyManager} TelephonyManager.CALL_STATE_IDLE <br> TelephonyManager.CALL_STATE_OFFHOOK <br> TelephonyManager.CALL_STATE_RINGING <br>
+     * @param incomingNumber pass null if you don't choose ringing!
+     * @param packageName the affected package to fake callstate!
+     * @author CollegeDev
+     */
+    public void notifyPrivacyCallState(int state, String incomingNumber, String packageName) {
+    	//we do not need to check for permissions
+//        if (!checkNotifyPermission("notifyCallState()")) {
+//            return;
+//        }
+        synchronized (mRecords) {
+            //mCallState = state;
+            //mCallIncomingNumber = incomingNumber;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                    try {
+                    	//only notify the affected application
+                    	if(r.pkgForDebug.equals(packageName)){
+                    		r.callback.onCallStateChanged(state, incomingNumber);
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        //broadcastCallStateChanged(state, incomingNumber);
+    }
+    
+    private void registerPrivacy(){
+    	 IntentFilter intentFilter = new IntentFilter("android.privacy.BLOCKED_PHONE_CALL");
+    	 mContext.registerReceiver(privacyReceiver, intentFilter);
+    }
+	
+	public void listen(String pkgForDebug, IPhoneStateListener callback, int events,
+            boolean notifyNow) {
+        // Slog.d(TAG, "listen pkg=" + pkgForDebug + " events=0x" +
+        // Integer.toHexString(events));
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			Log.e(P_TAG,"failed to register privacy broadcastreceiver");
+		}
+        if (events != 0) {
+            /* Checks permission and throws Security exception */
+            checkListenerPermission(events);
+
+            synchronized (mRecords) {
+                // register
+                Record r = null;
+                find_and_add: {
+                    IBinder b = callback.asBinder();
+                    final int N = mRecords.size();
+                    for (int i = 0; i < N; i++) {
+                        r = mRecords.get(i);
+                        if (b == r.binder) {
+                            break find_and_add;
+                        }
+                    }
+                    r = new Record();
+                    r.binder = b;
+                    r.callback = callback;
+                    r.pkgForDebug = pkgForDebug;
+                    mRecords.add(r);
+                }
+                int send = events & (events ^ r.events);
+                r.events = events;
+                if (notifyNow) {
+                    if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+//                        try {
+//                        	//not forward now, wait for next
+//                            //r.callback.onServiceStateChanged(new ServiceState(mServiceState));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
+                        try {
+                            int gsmSignalStrength = mSignalStrength.getGsmSignalStrength();
+                            r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1
+                                    : gsmSignalStrength));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onCallForwardingIndicatorChanged(mCallForwarding);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
+//                        try {
+//                        	//we do not forward now!
+//                            //r.callback.onCellLocationChanged(new Bundle(mCellLocation));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                        try {
+                            r.callback.onCallStateChanged(mCallState, mCallIncomingNumber);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
+                        try {
+                            r.callback.onDataConnectionStateChanged(mDataConnectionState,
+                                mDataConnectionNetworkType);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
+                        try {
+                            r.callback.onDataActivity(mDataActivity);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
+                        try {
+                            r.callback.onSignalStrengthsChanged(mSignalStrength);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
+                        try {
+                            r.callback.onOtaspChanged(mOtaspMode);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+//                        try {
+//                        	//we also do not forward now
+//                            //r.callback.onCellInfoChanged(new CellInfo(mCellInfo));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                }
+            }
+        } else {
+            remove(callback.asBinder());
+        }
+    }
+	
+	
+	private boolean isPackageAllowed(int PERMISSION, String packageName){
+		PrivacySettings settings = pSetMan.getSettings(packageName, Process.myUid());
+		if(settings == null) return false;
+		switch(PERMISSION){
+			case PERMISSION_CELL_LOCATION:
+				if(((settings.getLocationNetworkSetting() != PrivacySettings.REAL) || (settings.getLocationGpsSetting() != PrivacySettings.REAL)))
+					return false;
+				else 
+					return true;
+			case PERMISSION_CELL_INFO:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SIGNAL_STRENGTH:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_CALL_STATE:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SERVICE_STATE:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			default:
+				return false;
+		}
+	}
+
+	@Override
+	public void notifyServiceState(ServiceState state) {
+        if (!checkNotifyPermission("notifyServiceState()")){
+            return;
+        }
+        synchronized (mRecords) {
+            mServiceState = state;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_SERVICE_STATE,r.pkgForDebug)){
+                    		 state.setOperatorName("", "", "");
+                    		 Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for Cellinfo");
+                    	}
+                    	else
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for Cellinfo");
+                        r.callback.onServiceStateChanged(new ServiceState(state));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        broadcastServiceStateChanged(state);
+    }
+	
+	@Override
+	public void notifyCellInfo(List<CellInfo> cellInfo) {
+        if (!checkNotifyPermission("notifyCellInfo()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCellInfo = cellInfo;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_CELL_INFO,r.pkgForDebug)){
+                    		//for testings only at first
+                            CellInfoGsm fakeCellInfo = new CellInfoGsm(); 
+                            CellIdentityGsm fakeCellIdentity = new CellIdentityGsm(11,11,549,525,2);
+                            fakeCellInfo.setCellIdentity(fakeCellIdentity);
+                    		//r.callback.onCellInfoChanged(new CellInfoGsm(CellInfo.TIMESTAMP_TYPE_UNKNOWN,System.currentTimeMillis(),System.currentTimeMillis(),true,new SignalStrength(),new CellIdentityGsm(11,11,549,545,2,"unknown")));
+                    		r.callback.onCellInfoChanged(new ArrayList<CellInfo>(Arrays.asList(fakeCellInfo)));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for Cellinfo");
+                    	}
+                    	else{
+                    		r.callback.onCellInfoChanged(cellInfo);
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for Cellinfo");
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+	
+	@Override
+	public void notifyCellLocation(Bundle cellLocation) {
+        if (!checkNotifyPermission("notifyCellLocation()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCellLocation = cellLocation;
+            boolean isCDMA = false;
+            boolean goNormal = false;
+            try{
+            	if(cellLocation.containsKey("lac")){
+            		//it is gsm cell location object, handle it!
+            		isCDMA = false;
+            	}
+            	else{
+            		//it is cdma cell location object, handle it!
+            		isCDMA = true;
+            	}
+            }
+            catch(Exception e){
+            	//nothing here at all
+            	goNormal = true;
+            }
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_CELL_LOCATION,r.pkgForDebug) && !goNormal){
+                    		Bundle output = new Bundle();
+                    		if(isCDMA){
+                    			CdmaCellLocation tmp = new CdmaCellLocation();
+                    			tmp.fillInNotifierBundle(output);
+                    		}
+                    		else{
+                    			GsmCellLocation tmp = new GsmCellLocation();
+                    			tmp.fillInNotifierBundle(output);
+                    		}
+                    		r.callback.onCellLocationChanged(new Bundle(output));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for CellLocation");
+                    	}
+                    	else{
+                    		r.callback.onCellLocationChanged(new Bundle(cellLocation));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for CellLocation");
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 386750d..1947b35 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -77,6 +77,8 @@ import java.io.File;
 import java.util.Timer;
 import java.util.TimerTask;
 
+import android.privacy.PrivacySettingsManagerService;
+
 class ServerThread extends Thread {
     private static final String TAG = "SystemServer";
     private static final String ENCRYPTING_STATE = "trigger_restart_min_framework";
@@ -240,7 +242,7 @@ class ServerThread extends Thread {
             ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);
 
             Slog.i(TAG, "Telephony Registry");
-            telephonyRegistry = new TelephonyRegistry(context);
+            telephonyRegistry = new PrivacyTelephonyRegistry(context);
             ServiceManager.addService("telephony.registry", telephonyRegistry);
 
             Slog.i(TAG, "Scheduling Policy");
@@ -296,6 +298,8 @@ class ServerThread extends Thread {
             contentService = ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
 
+            addPrivacyService(context);
+
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
 
@@ -1051,6 +1055,15 @@ class ServerThread extends Thread {
         Slog.d(TAG, "Starting service: " + intent);
         context.startServiceAsUser(intent, UserHandle.OWNER);
     }
+
+    private void addPrivacyService(Context context) {
+        try {
+            Slog.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }        
+    }
 }
 
 public class SystemServer {
diff --git a/services/java/com/android/server/TelephonyRegistry.java b/services/java/com/android/server/TelephonyRegistry.java
index 26684de..0139882 100644
--- a/services/java/com/android/server/TelephonyRegistry.java
+++ b/services/java/com/android/server/TelephonyRegistry.java
@@ -63,7 +63,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     private static final boolean DBG = false;
     private static final boolean DBG_LOC = false;
 
-    private static class Record {
+    public static class Record {
         String pkgForDebug;
 
         IBinder binder;
@@ -81,29 +81,29 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private final Context mContext;
+    protected final Context mContext;
 
     // access should be inside synchronized (mRecords) for these two fields
-    private final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
-    private final ArrayList<Record> mRecords = new ArrayList<Record>();
+    protected final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
+    protected final ArrayList<Record> mRecords = new ArrayList<Record>();
 
     private final IBatteryStats mBatteryStats;
 
-    private int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
 
-    private String mCallIncomingNumber = "";
+    protected String mCallIncomingNumber = "";
 
-    private ServiceState mServiceState = new ServiceState();
+    protected ServiceState mServiceState = new ServiceState();
 
-    private SignalStrength mSignalStrength = new SignalStrength();
+    protected SignalStrength mSignalStrength = new SignalStrength();
 
-    private boolean mMessageWaiting = false;
+    protected boolean mMessageWaiting = false;
 
-    private boolean mCallForwarding = false;
+    protected boolean mCallForwarding = false;
 
-    private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
+    protected int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
 
-    private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
+    protected int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
 
     private boolean mDataConnectionPossible = false;
 
@@ -117,13 +117,13 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
 
     private LinkCapabilities mDataConnectionLinkCapabilities;
 
-    private Bundle mCellLocation = new Bundle();
+    protected Bundle mCellLocation = new Bundle();
 
-    private int mDataConnectionNetworkType;
+    protected int mDataConnectionNetworkType;
 
-    private int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
+    protected int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
 
-    private List<CellInfo> mCellInfo = null;
+    protected List<CellInfo> mCellInfo = null;
 
     static final int PHONE_STATE_PERMISSION_MASK =
                 PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR |
@@ -165,7 +165,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // calls go through a oneway interface and local calls going through a
     // handler before they get to app code.
 
-    TelephonyRegistry(Context context) {
+    protected TelephonyRegistry(Context context) {
         CellLocation  location = CellLocation.getEmpty();
 
         // Note that location can be null for non-phone builds like
@@ -312,7 +312,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void remove(IBinder binder) {
+    protected void remove(IBinder binder) {
         synchronized (mRecords) {
             final int recordCount = mRecords.size();
             for (int i = 0; i < recordCount; i++) {
@@ -351,9 +351,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
         synchronized (mRecords) {
             mServiceState = state;
+            mServiceState.setOperatorName("", "", "");
             for (Record r : mRecords) {
                 if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                     try {
+			            state.setOperatorName("", "", "");
                         r.callback.onServiceStateChanged(new ServiceState(state));
                     } catch (RemoteException ex) {
                         mRemoveList.add(r.binder);
@@ -639,7 +641,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // the legacy intent broadcasting
     //
 
-    private void broadcastServiceStateChanged(ServiceState state) {
+    protected void broadcastServiceStateChanged(ServiceState state) {
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneState(state.getState());
@@ -738,7 +740,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
     }
 
-    private boolean checkNotifyPermission(String method) {
+    protected boolean checkNotifyPermission(String method) {
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
                 == PackageManager.PERMISSION_GRANTED) {
             return true;
@@ -749,7 +751,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         return false;
     }
 
-    private void checkListenerPermission(int events) {
+    protected void checkListenerPermission(int events) {
         if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
             mContext.enforceCallingOrSelfPermission(
                     android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
@@ -768,7 +770,7 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void handleRemoveListLocked() {
+    protected void handleRemoveListLocked() {
         if (mRemoveList.size() > 0) {
             for (IBinder b: mRemoveList) {
                 remove(b);
diff --git a/services/java/com/android/server/am/BroadcastQueue.java b/services/java/com/android/server/am/BroadcastQueue.java
index f9630ae..efde52a 100644
--- a/services/java/com/android/server/am/BroadcastQueue.java
+++ b/services/java/com/android/server/am/BroadcastQueue.java
@@ -40,6 +40,8 @@ import android.os.UserHandle;
 import android.util.EventLog;
 import android.util.Slog;
 
+import android.privacy.surrogate.PrivacyActivityManagerService;
+
 /**
  * BROADCASTS
  *
@@ -634,6 +636,13 @@ public class BroadcastQueue {
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+
+            enforcePrivacyPermission(nextReceiver, r);
+            boolean empty = false;
+            if (r != null && r.intent != null && r.intent.getAction() != null && r.intent.getAction().equals("catchBootComplete")) {
+                empty = true;
+            }
+
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -642,7 +651,16 @@ public class BroadcastQueue {
                         "Delivering ordered ["
                         + mQueueName + "] to registered "
                         + filter + ": " + r);
-                deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                if (!empty) {
+                    deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                } else {
+                    //Log.i("PrivacyBroadcast","set r.receiver to null");
+                    r.receiver = null;
+                    r.curFilter = null;
+                    // Re-initalize
+                    r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+                }
+
                 if (r.receiver == null || !r.ordered) {
                     // The receiver has already finished, so schedule to
                     // process the next one.
@@ -734,6 +752,11 @@ public class BroadcastQueue {
                 skip = true;
             }
 
+            if (empty) {
+                skip = true;
+                r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+            }
+
             if (skip) {
                 if (DEBUG_BROADCAST)  Slog.v(TAG,
                         "Skipping delivery of ordered ["
@@ -814,6 +837,32 @@ public class BroadcastQueue {
         }
     }
 
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+            String packageName = null;
+            int uid = -1;
+
+            // Try to get intent receiver information
+            try {
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, null, r.receivers.size());
+            }
+        }
+    }
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
diff --git a/telephony/java/android/telephony/CellInfoGsm.java b/telephony/java/android/telephony/CellInfoGsm.java
index bd14d45..dd4145d 100644
--- a/telephony/java/android/telephony/CellInfoGsm.java
+++ b/telephony/java/android/telephony/CellInfoGsm.java
@@ -48,7 +48,7 @@ public final class CellInfoGsm extends CellInfo implements Parcelable {
     public CellIdentityGsm getCellIdentity() {
         return mCellIdentityGsm;
     }
-    /** @hide */
+
     public void setCellIdentity(CellIdentityGsm cid) {
         mCellIdentityGsm = cid;
     }
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index f3ccae6..7d448a6 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -16,6 +16,11 @@
 
 package android.telephony;
 
+import com.android.internal.telephony.IPhoneStateListener;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.content.Context;
+
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
@@ -158,6 +163,26 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_OTASP_CHANGED                            = 0x00000200;
 
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+
     /**
      * Listen for changes to observed cell info.
      *
@@ -317,11 +342,43 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // Simply block the method call, since simulating cell location is not feasible
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                } else {
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                }
+                //Log.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + 
+                //    Binder.getCallingUid() + ") output: " + output);
+            }
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            //Log.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // Only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+                    //Log.d(TAG, "onCallStateChanged BLOCK - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+                    //Log.d(TAG, "onCallStateChanged REAL 1 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+                //Log.d(TAG, "onCallStateChanged REAL 2 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index a9a5e90..b8ba2b6 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -484,7 +484,7 @@ public class ServiceState implements Parcelable {
                 + " EmergOnly=" + mIsEmergencyOnly);
     }
 
-    private void setNullState(int state) {
+    void setNullState(int state) {
         mState = state;
         mRoaming = false;
         mOperatorAlphaLong = null;
diff --git a/wifi/java/android/net/wifi/WifiInfo.java b/wifi/java/android/net/wifi/WifiInfo.java
index 05db571..71c3688 100644
--- a/wifi/java/android/net/wifi/WifiInfo.java
+++ b/wifi/java/android/net/wifi/WifiInfo.java
@@ -78,6 +78,20 @@ public class WifiInfo implements Parcelable {
      */
     private boolean mMeteredHint;
 
+    /**
+     * Constructor for faking WifiInfo
+     * @hide
+     */
+    public WifiInfo(boolean fake) {
+        mWifiSsid = WifiSsid.createFromAsciiEncoded("");
+        mBSSID = "";
+        mNetworkId = -1;
+        mSupplicantState = SupplicantState.UNINITIALIZED;
+        mRssi = -9999;
+        mLinkSpeed = -1;
+        mHiddenSSID = false;
+    }
+
     WifiInfo() {
         mWifiSsid = null;
         mBSSID = null;
-- 
1.8.0.3

