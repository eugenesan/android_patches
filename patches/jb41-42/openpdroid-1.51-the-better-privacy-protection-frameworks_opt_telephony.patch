From a7b661fa7f04e794af1312c845e51c7fbbda6f2f Mon Sep 17 00:00:00 2001
From: Simeon Morgan <smorgan@digitalfeed.net>
Date: Wed, 19 Dec 2012 16:59:54 +1100
Subject: [PATCH] openpdroid 1.51 - the better privacy protection

OpenPDroid is a set of modifications to the Android framework and
libraries which allows fine-tuning of the data which applications
are able to retrieve about your device, your account, your messages,
and more. Specifically, it is a Privacy service provider
(using the PDroid 1.51 interface) forked from CollegeDev's PDroid 2.0,
which is itself an extension of Syvat's PDroid.

What (specifically) can I control with OpenPDroid?
Data access:
    Device ID (IMEI/MEID/ESN)
    Phone/voicemail number
    Sim Card Serial (ICCID)
    Subscriber ID (IMSI)
    Source number of incoming calls
    Destination number of outgoing calls
    Network location
    GPS location
    Authentication credentials
    List of accounts, including identifiers (e.g. gmail e-mail address)
    Contact list and details
    Call log
    Calendar
    Read and send SMS
    Read and send MMS
    Record audio (not phone calls)
    Camera
    Browser bookmarks and history
    System logs
    Wifi Info, such as current access point, IP address
    Network information (detailed network information such as
    connection state, IP address, etc)
    Android ID (a unique installation ID for your Android installation)
    SIM information (your phone operator and country)
    Restrict access to iptables command
    ICC Access (reading or writing SMS on the SIM or R-UIM)

Actions:
    Make phone calls
    Start on Boot (or more accurately, get notified when the boot is complete)
    Switch Wifi State (turn wifi on and off, change access points)
    Switch network state (turn off or on mobile data)

Other:
    Force online state (always tell the app that the device is online: only
    needed if denying Wifi info and/or Network info)

Change-Id: I4bb75a0556f194f91ad1414250d134f8583394c2
---
 .../privacy/surrogate/PrivacyCDMALTEPhone.java     | 320 +++++++++++
 .../privacy/surrogate/PrivacyCDMAPhone.java        | 300 ++++++++++
 .../android/privacy/surrogate/PrivacyGSMPhone.java | 302 ++++++++++
 .../privacy/surrogate/PrivacyPhoneProxy.java       | 632 +++++++++++++++++++++
 .../android/privacy/surrogate/PrivacySipPhone.java | 301 ++++++++++
 .../android/internal/telephony/PhoneFactory.java   |  53 +-
 .../android/internal/telephony/SMSDispatcher.java  | 148 ++++-
 .../android/internal/telephony/cdma/CDMAPhone.java |   2 +-
 .../telephony/cdma/CdmaServiceStateTracker.java    |  98 +++-
 .../telephony/cdma/RuimSmsInterfaceManager.java    | 150 ++++-
 .../android/internal/telephony/gsm/GSMPhone.java   |   4 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |  76 ++-
 .../telephony/gsm/SimSmsInterfaceManager.java      | 141 +++++
 .../android/internal/telephony/sip/SipPhone.java   |   2 +-
 .../internal/telephony/sip/SipPhoneFactory.java    |   3 +-
 15 files changed, 2485 insertions(+), 47 deletions(-)
 create mode 100644 src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
 create mode 100644 src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
 create mode 100644 src/java/android/privacy/surrogate/PrivacyGSMPhone.java
 create mode 100644 src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
 create mode 100644 src/java/android/privacy/surrogate/PrivacySipPhone.java

diff --git a/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
new file mode 100644
index 0000000..a78cfb7
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
@@ -0,0 +1,320 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMALTEPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMALTEPhone extends CDMALTEPhone{
+
+	private static final String P_TAG = "PrivacyCDMALTEPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context, cmdI, pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getMsisdn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMsisdn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMsisdn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+//	public IsimRecords getIsimRecords() {
+//		return null;
+//	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
new file mode 100644
index 0000000..783c049
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
@@ -0,0 +1,300 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMAPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyCDMAPhone extends CDMAPhone{
+
+	private static final String P_TAG = "PrivacyCDMAPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMAPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyGSMPhone.java b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
new file mode 100644
index 0000000..61a9dae
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
@@ -0,0 +1,302 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.gsm.GSMPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyGSMPhone extends GSMPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyGSMPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff --git a/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
new file mode 100644
index 0000000..766560a
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
@@ -0,0 +1,632 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+import android.os.Process;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+
+import com.android.internal.telephony.PhoneConstants;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * @deprecated normally this class is not neeeded anymore, since we got privacy phones. The only method which is interesting is getPhoneSubInfo 
+ * {@hide}
+ */
+
+public class PrivacyPhoneProxy extends PhoneProxy{
+
+	private static final String P_TAG = "PrivacyPhoneProxy";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	private boolean context_available;
+	
+	/** This PackageManager is needed to get package name if context is not available*/
+	private IPackageManager mPm;
+	
+	public PrivacyPhoneProxy(PhoneBase mPhone, Context context) { //not sure if context is available, so test it!
+		super(mPhone);
+		if(context != null){
+			this.context = context;
+			context_available = true;
+		}
+		else{
+			context_available = false;
+		}
+		initiate(context_available);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	/**
+	 * Method for initalize variables depends on context is availabe or not
+	 * @param ctx_av pass true, if context is available and false if not
+	 * {@hide}
+	 */
+	private void initiate(boolean ctx_av){
+		if(ctx_av){
+			Log.i(P_TAG,"Context is available for package:" + context.getPackageName());
+		} else{
+			Log.e(P_TAG,"Context is not available for package: " + context.getPackageName());
+			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+		}
+	}
+	
+	
+	/**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(P_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    
+    @Override
+    public Connection dial(String dialNumber) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.dial(dialNumber); 
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], -1);
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber); 
+			}
+			else{
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+    
+    @Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.dial(dialNumber, uusInfo);
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], -1);
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo); 
+			}
+			else{
+				pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+
+	@Override
+	public CellLocation getCellLocation() {
+		int phone_type = super.getPhoneType();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+		}
+		else{ //context is not available, go through uid!
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getCellLocation(); //we give cell location, because we can't get any package information in this process
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+		}
+	}
+	
+	@Override
+	public PhoneConstants.DataState getDataConnectionState() {
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING; //it's the best way to tell system that we are connecting
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDataConnectionState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING;
+			}
+		}
+	}
+	
+//	@Override
+//	public State getState() {
+//		State.
+//		return null;
+//	}
+	
+//	@Override
+//	public String getPhoneName() {
+//		return null;
+//	}
+	
+//	@Override
+//	public int getPhoneType() {
+//		return 0;
+//	}
+	
+	@Override
+	public SignalStrength getSignalStrength() {
+		SignalStrength output = new SignalStrength();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSignalStrength();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+		}
+	}
+	
+//	@Override
+//	public IccCard getIccCard() {
+//		return null;
+//	}
+
+	@Override
+	public String getLine1Number() {
+	   if(context_available){
+		   String packageName = context.getPackageName();
+	       int uid = Process.myUid();
+	       PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	       String output;
+	       if (pSet != null && pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+	           output = pSet.getLine1Number(); // can be empty, custom or random
+	           pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getLine1Number()");
+	       } else {
+	           output = super.getLine1Number();
+	           pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+	           Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getLine1Number()");
+	       }
+	       return output;
+	   }
+	   else{
+		    String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getLine1Number();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getLine1Number()");
+				return output;
+			}
+			else{
+				output = settings.getLine1Number();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getLine1Number()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the Line1Number.
+	 */
+	@Override
+	public String getLine1AlphaTag() {
+		return getLine1Number();
+	}
+	
+	/**
+	 * Will be handled like the Line1Number, since voice mailbox numbers often
+	 * are similar to the phone number of the subscriber.
+	 */
+	@Override
+	public String getVoiceMailNumber() {
+		return getLine1Number();
+	}
+	
+	//will look at this later!
+//	@Override
+//	public void getNeighboringCids(Message response) {
+//		
+//	}
+	
+	@Override
+	public String getDeviceId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getDeviceId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDeviceId()");
+	        } else {
+	            output = super.getDeviceId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDeviceId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getDeviceId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getDeviceIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDeviceId()");
+				return output;
+			}
+			else{
+				output = settings.getDeviceId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDeviceId()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getDeviceSvn() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        int uid = Process.myUid();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getSubscriberId(); // can be empty, custom or random
+	            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSubscriberId()");
+	        } else {
+	            output = super.getSubscriberId();
+	            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSubscriberId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getSubscriberId();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getSubscriberIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSubscriberId()");
+				return output;
+			}
+			else{
+				output = settings.getSubscriberId();
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], Process.myUid(), settings.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSubscriberId()");
+				return output;
+			}
+		}
+		
+	}
+	
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getIccSerialNumber() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getEsn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMeid() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMsisdn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getImei() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo(){
+		PhoneSubInfo output = new PhoneSubInfo(this);
+		return output;
+	}
+	
+	@Override
+	public ServiceState getServiceState(){
+		ServiceState output;
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				//output.setRadioTechnology(-1);
+				return output;
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			if(package_names == null) return super.getServiceState();
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i], Process.myUid());
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+			else{
+				if(settings != null)
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				Log.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+		}
+	}
+	
+	
+}
diff --git a/src/java/android/privacy/surrogate/PrivacySipPhone.java b/src/java/android/privacy/surrogate/PrivacySipPhone.java
new file mode 100644
index 0000000..f7a1a28
--- /dev/null
+++ b/src/java/android/privacy/surrogate/PrivacySipPhone.java
@@ -0,0 +1,301 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.net.sip.SipProfile;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.sip.SipPhone;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacySipPhone extends SipPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacySipPhone(Context context, PhoneNotifier pN, SipProfile sP) {
+		super(context, pN, sP); //I've changed the constructor to public!
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+        return output;
+	}
+	
+
+//	void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && (settings.getLocationGpsSetting() != PrivacySettings.REAL || settings.getLocationNetworkSetting() != PrivacySettings.REAL)){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL,PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				return output;
+			}
+			else{
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			e.printStackTrace();
+			Log.e(P_TAG,"We got exception in getServiceState()-> give fake state");
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 49b5471..1a9dfbd 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -24,14 +24,25 @@ import android.telephony.TelephonyManager;
 import android.util.Log;
 import android.os.SystemProperties;
 
-import com.android.internal.telephony.cdma.CDMAPhone;
-import com.android.internal.telephony.cdma.CDMALTEPhone;
+//import com.android.internal.telephony.cdma.CDMAPhone;
+//import com.android.internal.telephony.cdma.CDMALTEPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
-import com.android.internal.telephony.gsm.GSMPhone;
+//import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.sip.SipPhone;
 import com.android.internal.telephony.sip.SipPhoneFactory;
 import com.android.internal.telephony.uicc.UiccController;
 
+//--------------------------------------------------------
+import android.privacy.surrogate.PrivacyCDMAPhone;
+import android.privacy.surrogate.PrivacyCDMALTEPhone;
+import android.privacy.surrogate.PrivacyGSMPhone;
+import android.privacy.surrogate.PrivacySipPhone;
+//--------------------------------------------------------
+
+//BEGIN PRIVACY ADDED
+import android.privacy.surrogate.PrivacyPhoneProxy;
+//END PRIVACY ADDED
+
 /**
  * {@hide}
  */
@@ -148,20 +159,32 @@ public class PhoneFactory {
                 int phoneType = TelephonyManager.getPhoneType(networkMode);
                 if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                     Log.i(LOG_TAG, "Creating GSMPhone");
-                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
-                            sCommandsInterface, sPhoneNotifier));
+                    //BEGIN PRIVACY ADDED
+                    //sProxyPhone = new PhoneProxy(new GSMPhone(context,
+                    //        sCommandsInterface, sPhoneNotifier));
+                    sProxyPhone = new PrivacyPhoneProxy(new PrivacyGSMPhone(context,
+                            sCommandsInterface, sPhoneNotifier),context);
+                    //END PRIVACY ADDED
                 } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                     switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                         case PhoneConstants.LTE_ON_CDMA_TRUE:
                             Log.i(LOG_TAG, "Creating CDMALTEPhone");
-                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
-                                sCommandsInterface, sPhoneNotifier));
+                            //BEGIN PRIVACY ADDED
+                            //sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
+                            //    sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMALTEPhone(context,
+                                sCommandsInterface, sPhoneNotifier),context);
+                            //END PRIVACY ADDED
                             break;
                         case PhoneConstants.LTE_ON_CDMA_FALSE:
                         default:
                             Log.i(LOG_TAG, "Creating CDMAPhone");
-                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
-                                    sCommandsInterface, sPhoneNotifier));
+                            //BEGIN PRIVACY ADDED
+                            //sProxyPhone = new PhoneProxy(new CDMAPhone(context,
+                            //        sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMAPhone(context,
+                                    sCommandsInterface, sPhoneNotifier),context);
+                            //END PRIVACY ADDED
                             break;
                     }
                 }
@@ -188,13 +211,19 @@ public class PhoneFactory {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
             switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                 case PhoneConstants.LTE_ON_CDMA_TRUE: {
-                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
                 case PhoneConstants.LTE_ON_CDMA_FALSE:
                 case PhoneConstants.LTE_ON_CDMA_UNKNOWN:
                 default: {
-                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //BEGIN PRIVACY ADDED
+                    //phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    //END PRIVACY ADDED
                     break;
                 }
             }
@@ -204,7 +233,7 @@ public class PhoneFactory {
 
     public static Phone getGsmPhone() {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
-            Phone phone = new GSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            Phone phone = new PrivacyGSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
             return phone;
         }
     }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index 6740372..55f89af 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -74,6 +74,13 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.HashMap;
 import java.util.Random;
 
+// BEGIN PRIVACY ADDED
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END PRIVACY ADDED
+
 import static android.telephony.SmsManager.RESULT_ERROR_FDN_CHECK_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_LIMIT_EXCEEDED;
@@ -196,6 +203,123 @@ public abstract class SMSDispatcher extends Handler {
         sConcatenatedRef += 1;
         return sConcatenatedRef;
     }
+    
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSDispatcher";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    	        default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
 
     /**
      * Create a new SMS dispatcher.
@@ -218,7 +342,13 @@ public abstract class SMSDispatcher extends Handler {
                 Settings.Global.SMS_SHORT_CODE_RULE), false, mSettingsObserver);
 
         createWakelock();
-
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
+        if(pSetMan == null) new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         mSmsCapable = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_sms_capable);
         mSmsReceiveDisabled = !SystemProperties.getBoolean(
@@ -846,7 +976,7 @@ public abstract class SMSDispatcher extends Handler {
     protected void sendMultipartText(String destAddr, String scAddr,
             ArrayList<String> parts, ArrayList<PendingIntent> sentIntents,
             ArrayList<PendingIntent> deliveryIntents) {
-
+    	
         int refNumber = getNextConcatenatedRef() & 0x00FF;
         int msgCount = parts.size();
         int encoding = SmsConstants.ENCODING_UNKNOWN;
@@ -864,7 +994,7 @@ public abstract class SMSDispatcher extends Handler {
             encodingForParts[i] = details;
         }
 
-        for (int i = 0; i < msgCount; i++) {
+        for (int i = 0; i < msgCount; i++) { 
             SmsHeader.ConcatRef concatRef = new SmsHeader.ConcatRef();
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
@@ -950,7 +1080,17 @@ public abstract class SMSDispatcher extends Handler {
             }
             return;
         }
-
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(), ACCESS_TYPE_SMS_MMS)){
+        	if (sentIntent != null) {
+                try {
+                    sentIntent.send(RESULT_ERROR_GENERIC_FAILURE);
+                    Log.i(TAG,"fake also delivery state to radio off!");
+                } catch (CanceledException e) {}
+            }
+        	return;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         HashMap<String, Object> map = new HashMap<String, Object>();
         map.put("smsc", smsc);
         map.put("pdu", pdu);
diff --git a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index c43888b..06de679 100755
--- a/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -822,7 +822,7 @@ public class CDMAPhone extends PhoneBase {
          super.notifyServiceStateChangedP(ss);
      }
 
-     void notifyLocationChanged() {
+     public void notifyLocationChanged() {
          mNotifier.notifyCellLocation(this);
      }
 
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 2554691..82880d6 100755
--- a/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -68,6 +68,15 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+/////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+/////////////////////////////////////////////////////////
+
+
 /**
  * {@hide}
  */
@@ -121,6 +130,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     String mSavedTimeZone;
     long mSavedTime;
     long mSavedAtTime;
+    
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
 
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
@@ -203,6 +217,11 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             Settings.System.getUriFor(Settings.System.AUTO_TIME_ZONE), true,
             mAutoTimeZoneObserver);
         setSignalStrengthDefaultValues();
+
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
     }
 
     @Override
@@ -371,10 +390,21 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                         loge("error parsing cell location data: " + ex);
                     }
                 }
-
-                cellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                	//we will update with invalid cell location values
+                	cellLoc.setStateInvalid();
+                }
+                else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                	Random values = new Random();
+                	cellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+                }
+                else{
+                	cellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+                }
                 phone.notifyLocationChanged();
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             // Release any temporary cell lock, which could have been
@@ -569,6 +599,7 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     protected void handlePollStateResultMessage(int what, AsyncResult ar){
         int ints[];
         String states[];
+  	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
         switch (what) {
         case EVENT_POLL_STATE_REGISTRATION_CDMA: // Handle RIL_REQUEST_REGISTRATION_STATE.
             states = (String[])ar.result;
@@ -658,8 +689,19 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
 
 
             // Values are -1 if not available.
-            newCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                    baseStationLongitude, systemId, networkId);
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
+            if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+            	//we will update with invalid cell location and station values
+            	newCellLoc.setStateInvalid();
+            }
+            else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+            	Random values = new Random();
+            	newCellLoc.setCellLocationData(values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt(), values.nextInt());
+            }
+            else{
+            	newCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+            }
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
 
             if (reasonForDenial == 0) {
                 mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
@@ -690,14 +732,25 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                                 "'= " + opNames[2]);
                     }
                 }
-
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
                 if (!isSubscriptionFromRuim) {
                     // In CDMA in case on NV, the ss.mOperatorAlphaLong is set later with the
                     // ERI text, so here it is ignored what is coming from the modem.
-                    newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName(null, "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	}
                 } else {
-                    newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName("", "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	}
                 }
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
             } else {
                 if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
             }
@@ -998,15 +1051,30 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
             if ((cm.getRadioState().isOn()) && (!isSubscriptionFromRuim)) {
                 String eriText;
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
-                if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
-                    eriText = phone.getCdmaEriText();
-                } else {
-                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
-                    // mRegistrationState 0,2,3 and 4
-                    eriText = phone.getContext().getText(
-                            com.android.internal.R.string.roamingTextSearching).toString();
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = "";
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
+                } else{
+                	//original code
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = phone.getCdmaEriText();
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
                 }
                 ss.setOperatorAlphaLong(eriText);
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             String operatorNumeric;
diff --git a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
index 9cd059d..291b450 100644
--- a/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
@@ -22,18 +22,27 @@ import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
-
 import com.android.internal.telephony.IccConstants;
 import com.android.internal.telephony.IccSmsInterfaceManager;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.PhoneProxy;
 import com.android.internal.telephony.SMSDispatcher;
 import com.android.internal.telephony.SmsRawData;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+
+/////////////////////////////////////////////////////////////
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+/////////////////////////////////////////////////////////////
+
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -51,6 +60,122 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_LOAD_DONE = 1;
     private static final int EVENT_UPDATE_DONE = 2;
 
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+	//-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    			default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    		
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
     Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -114,6 +239,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ pdu + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Updating message on RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -150,6 +282,13 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
         //NOTE smsc not used in RUIM
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +312,12 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
@@ -218,5 +363,6 @@ public class RuimSmsInterfaceManager extends IccSmsInterfaceManager {
     protected void log(String msg) {
         Log.d(LOG_TAG, "[RuimSmsInterfaceManager] " + msg);
     }
+    
 }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 393d101..419b79d 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -353,7 +353,7 @@ public class GSMPhone extends PhoneBase {
     /**
      * Notify any interested party of a Phone state change {@link PhoneConstants.State}
      */
-    /*package*/ void notifyPhoneStateChanged() {
+    /*package*/ public void notifyPhoneStateChanged() {
         mNotifier.notifyPhoneState(this);
     }
 
@@ -391,7 +391,7 @@ public class GSMPhone extends PhoneBase {
     }
 
     /*package*/
-    void notifyLocationChanged() {
+    public void notifyLocationChanged() {
         mNotifier.notifyCellLocation(this);
     }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 6110bd1..8baf415 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -53,6 +53,7 @@ import android.os.Message;
 import android.os.PowerManager;
 import android.os.Registrant;
 import android.os.RegistrantList;
+
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
@@ -67,7 +68,6 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.TimeUtils;
-
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -78,6 +78,14 @@ import java.util.Date;
 import java.util.HashSet;
 import java.util.TimeZone;
 
+//////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import java.util.Random;
+//////////////////////////////////////////////////////////
+
 /**
  * {@hide}
  */
@@ -89,7 +97,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     GsmCellLocation cellLoc;
     GsmCellLocation newCellLoc;
     int mPreferredNetworkType;
-
+    
+    //--------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //--------------------------------------------------------------------------
+    
     private int gprsState = ServiceState.STATE_OUT_OF_SERVICE;
     private int newGPRSState = ServiceState.STATE_OUT_OF_SERVICE;
     private int mMaxDataCalls = 1;
@@ -234,7 +247,13 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         phone.getContext().registerReceiver(mIntentReceiver, filter);
-
+        
+        //--------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //--------------------------------------------------------------------------
+        
+        
         // Gsm doesn't support OTASP so its not needed
         phone.notifyOtaspChanged(OTASP_NOT_NEEDED);
     }
@@ -342,8 +361,24 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             Log.w(LOG_TAG, "error parsing location: " + ex);
                         }
                     }
-                    cellLoc.setLacAndCid(lac, cid);
-                    phone.notifyLocationChanged();
+                    //---------------------------------------------------------------------------------------------------------------------
+                    PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	cellLoc.setStateInvalid();
+                    	phone.notifyLocationChanged();
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	cellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        phone.notifyLocationChanged();
+                    }
+                    else{
+                    	cellLoc.setLacAndCid(lac, cid);
+                        phone.notifyLocationChanged();
+                    }
+                    //---------------------------------------------------------------------------------------------------------------------
+                    
                 }
 
                 // Release any temporary cell lock, which could have been
@@ -604,6 +639,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                         ar.exception);
             }
         } else try {
+        	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
             switch (what) {
                 case EVENT_POLL_STATE_REGISTRATION:
                     states = (String[])ar.result;
@@ -643,8 +679,23 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     }
 
                     // LAC and CID are -1 if not avail
-                    newCellLoc.setLacAndCid(lac, cid);
-                    newCellLoc.setPsc(psc);
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.EMPTY){
+                    	//we will update with invalid cell location values
+                    	newCellLoc.setStateInvalid();
+                        newCellLoc.setPsc(psc);
+                    }
+                    else if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() == PrivacySettings.RANDOM){
+                    	Random values = new Random();
+                    	newCellLoc.setLacAndCid(values.nextInt(), values.nextInt());
+                        newCellLoc.setPsc(psc);
+                    }
+                    else{
+                    	newCellLoc.setLacAndCid(lac, cid);
+                        newCellLoc.setPsc(psc);
+                    }
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    
                 break;
 
                 case EVENT_POLL_STATE_GPRS:
@@ -682,7 +733,14 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                     String opNames[] = (String[])ar.result;
 
                     if (opNames != null && opNames.length >= 3) {
-                         newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                    	//--------------------------------------------------------------------------------------------------------------------------------
+                        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                        	newSS.setOperatorName ("", "", "");
+                        }
+                        else{
+                        	newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                        }
+                        //--------------------------------------------------------------------------------------------------------------------------------
                     }
                 break;
 
@@ -1041,7 +1099,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
 
         if (hasLocationChanged) {
-            phone.notifyLocationChanged();
+            phone.notifyLocationChanged(); //we can notify, because all sensitive data has changed before @author CollegeDev
         }
 
         if (! isGprsConsistent(gprsState, ss.getState())) {
diff --git a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
index 92bf390..7baf1ea 100644
--- a/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
@@ -38,6 +38,13 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+//////////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+/////////////////////////////////////////////////////////////
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -63,6 +70,122 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     private static final int EVENT_SET_BROADCAST_CONFIG_DONE = 4;
     private static final int SMS_CB_CODE_SCHEME_MIN = 0;
     private static final int SMS_CB_CODE_SCHEME_MAX = 255;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	     
+    	        		return true;
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i], -1);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		if(packageNames != null && packageNames.length > 0)
+    	        			notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        			
+    	        		return true;
+    	        	}
+    	        default:
+    	        	notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        	return true;
+    		}
+    		
+    	}
+    	catch(Exception e){
+    		Log.e(P_TAG,"Got exception while checking for sms or ICC acess permission");
+    		e.printStackTrace();
+    		if(packageNames != null && pSetMan != null && packageNames.length > 0){
+    			PrivacySettings settings = pSetMan.getSettings(packageNames[0], -1);
+    			if(settings != null)
+    				notify(accessType, packageNames[0],PrivacySettings.REAL);
+    		}
+    		return true;
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
 
     Handler mHandler = new Handler() {
         @Override
@@ -136,6 +259,11 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ Arrays.toString(pdu) + ")");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         enforceReceiveAndSend("Updating message on SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +301,13 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) +
                 "), smsm=(" + Arrays.toString(smsc) +")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -198,6 +333,12 @@ public class SimSmsInterfaceManager extends IccSmsInterfaceManager {
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
diff --git a/src/java/com/android/internal/telephony/sip/SipPhone.java b/src/java/com/android/internal/telephony/sip/SipPhone.java
index 346b126..fe91894 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhone.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhone.java
@@ -61,7 +61,7 @@ public class SipPhone extends SipPhoneBase {
     private SipManager mSipManager;
     private SipProfile mProfile;
 
-    SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
+    public SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
         super(context, notifier);
 
         if (DEBUG) Log.d(LOG_TAG, "new SipPhone: " + profile.getUriString());
diff --git a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
index 611e3ea..d4ddc1d 100644
--- a/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
+++ b/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
@@ -21,6 +21,7 @@ import com.android.internal.telephony.PhoneNotifier;
 import android.content.Context;
 import android.net.sip.SipProfile;
 import android.util.Log;
+import android.privacy.surrogate.PrivacySipPhone;
 
 import java.text.ParseException;
 
@@ -40,7 +41,7 @@ public class SipPhoneFactory {
             PhoneNotifier phoneNotifier) {
         try {
             SipProfile profile = new SipProfile.Builder(sipUri).build();
-            return new SipPhone(context, phoneNotifier, profile);
+            return new PrivacySipPhone(context, phoneNotifier, profile);
         } catch (ParseException e) {
             Log.w("SipPhoneFactory", "makePhone", e);
             return null;
-- 
1.8.0.3

